[333. 最大 BST 子树](https://leetcode.cn/problems/largest-bst-subtree)

[ChatGPT](https://chat.openai.com/share/92c75094-06b7-448f-9d2a-9619a8ede6dd)

---

## 1. 问题的内容
**1.1 题目描述**：
- 题目要求开发一个算法来找到给定二叉树中最大的二叉搜索树（BST）子树，并返回该子树的节点数量。二叉搜索树定义为：节点的左子树只包含小于当前节点的数，节点的右子树只包含大于当前节点的数，左右子树也必须是二叉搜索树。

**1.2 示例**：
- 例如，给定二叉树 `[10,5,15,1,8,null,7]`，最大的BST子树是 `[10,5,15,1,8]`，因此答案是5。

**1.3 提示**:
- 树中节点数目在范围 `[0, 104]` 内
- `-104 <= Node.val <= 104`

## 2. 边界情况和约束
- **边界情况**：
  - 树为空时，最大BST子树的大小为0。
  - 树只有一个节点时，这个节点本身就是一个BST，最大BST子树的大小为1。
  - 所有节点值相同的树不构成BST（除非树只有一个节点），因此需要考虑这种情况。

- **约束**：
  - 节点值的范围是 `-104 <= Node.val <= 104`，需要处理节点值为这个范围边界的情况。
  - 节点数量的范围是 `[0, 104]`，算法需要能够有效处理大量节点。

## 3. 算法和策略
我们采用**后序遍历**的方式来设计算法，这样我们可以从叶子节点开始，逐步向上验证每个节点是否满足BST的条件。算法的关键在于对每个节点，我们需要返回四个信息：

1. 当前子树是否是BST。
2. 当前子树中所有节点的最小值。
3. 当前子树中所有节点的最大值。
4. 如果当前子树是BST，它的节点数量。

**算法步骤**：

1. 对于每个节点，我们通过递归地调用其左右子节点来获取以上四个信息。
2. 如果一个节点的左右子树都是BST，且该节点的值大于左子树中的最大值，小于右子树中的最小值，则当前树是BST。此时，当前BST的大小是左右子树大小之和加一。
3. 如果左右子树中任何一个不是BST，或者当前节点的值不满足BST的条件，则当前子树不是BST。在这种情况下，我们只需要考虑左右子树中最大的BST子树大小。
4. 我们使用一个全局变量来跟踪遍历过程中发现的最大BST子树的大小。

---