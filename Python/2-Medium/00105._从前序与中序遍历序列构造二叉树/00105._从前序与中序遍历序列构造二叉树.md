[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal)

[ChatGPT](https://chat.openai.com/share/29a280d8-8f8a-4b25-94e8-04682bfe555f)

---

## 1. 问题的内容
**1.1 题目描述**：
在这个问题中，我们被要求根据二叉树的前序遍历和中序遍历的结果来重建原始二叉树。前序遍历的顺序是先访问根节点，然后是左子树，最后是右子树。中序遍历的顺序是先访问左子树，然后是根节点，最后是右子树。我们需要利用这两个序列来构造出原始的二叉树。

**1.2 示例**：
假设前序遍历的结果是 `[3, 9, 20, 15, 7]`，中序遍历的结果是 `[9, 3, 15, 20, 7]`。根据这两个序列，我们应该能够重建出原始的二叉树结构。

**1.3 提示**:
- 前序遍历的第一个元素总是树的根节点。
- 在中序遍历序列中，根节点左边的所有元素都属于左子树，根节点右边的所有元素都属于右子树。
- 利用这个特性，我们可以递归地构造出整个树。

## 2. 边界情况和约束
- **边界情况**:
  - 如果前序遍历或中序遍历序列为空，那么树也为空。
  - 如果序列只包含一个元素，那么这个元素就是树的根节点，且这棵树没有子节点。

- **约束**:
  - 前序遍历和中序遍历序列中的所有节点值都是唯一的，这是重建二叉树的前提条件之一。
  - 前序遍历和中序遍历序列的长度相同，并且都是原始树中所有节点的完整表示。


## 3. 算法和策略
1. **初始化**：创建一个映射（哈希表），用于快速查找中序遍历中每个值的索引，这将帮助我们快速确定根节点、左子树和右子树的范围。

2. **定义递归函数**：这个函数接受前序遍历和中序遍历的索引范围，用于确定当前子树的范围。
   - 提取当前子树的根节点，即前序遍历序列中的第一个元素。
   - 在中序遍历序列中找到根节点的索引，这将中序遍历序列分为左右两个部分，分别对应左子树和右子树。
   - 递归调用自身来构建左子树和右子树。

3. **递归的基准情况**：如果当前的索引范围为空，返回None。

4. **构建树**：从前序遍历的第一个元素（全局根节点）开始，使用递归函数构建整棵树，并返回树的根节点。

---