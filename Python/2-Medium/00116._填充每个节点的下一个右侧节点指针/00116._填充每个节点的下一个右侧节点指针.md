[116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node)

[ChatGPT](https://chat.openai.com/share/03a8943f-c6d6-4aa1-a449-418537b7a8a5)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode 116题目要求是填充每个节点的下一个右侧节点指针。给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
```python
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
```

**1.2 示例**：
考虑一个完美二叉树如下所示：

```
     1
   /  \
  2    3
 / \  / \
4  5  6  7
```

经过算法处理后，树应该变为：

```
     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \  / \
4->5->6->7 -> NULL
```

**1.3 提示**:
- 你只能使用常量级额外空间。
- 使用递归方法也需要进行适当的修改，这种方式会增加调用栈的空间消耗。

## 2. 边界情况和约束
- **边界情况**:
  - 空树的情况，即树中没有节点。
  - 只有根节点的情况，没有子节点。
  - 完美二叉树的定义是所有叶子都在同一层，并且每个父节点都有两个子节点，这意味着我们不需要处理不平衡的树。

- **约束**:
  - 只能使用常量级额外空间，这意味着不能使用额外的数据结构来存储每层的节点。
  - 递归解法需要考虑递归调用栈的空间。

## 3. 算法和策略
算法思路：
1. **层序遍历**（使用已建立的 `next` 指针）:
   - 从根节点开始，因为根节点的 `next` 已经是 `NULL`，符合题目要求。
   - 对于树的每一层，通过已经建立的 `next` 指针遍历该层的所有节点，为下一层的节点设置 `next` 指针。
   - 对于每个节点，其左子节点的 `next` 指针应指向其右子节点，其右子节点的 `next` 指针应指向父节点 `next` 的左子节点（如果父节点的 `next` 为 `NULL`，则右子节点的 `next` 也为 `NULL`）。

2. **递归实现**:
   - 递归地连接每一层的节点，递归函数接收两个节点，连接这两个节点的子节点。
   - 对于树中的任意两个相邻节点，连接它们的子节点，然后递归地对这些子节点进行相同的操作。

步骤详解：
1. **初始条件**: 如果根节点为空，直接返回 `NULL`。
2. **连接同一父节点的子节点**: 对于每个节点，使其左子节点的 `next` 指向其右子节点。
3. **连接不同父节点但相邻的子节点**: 如果节点的 `next` 不为空，则该节点的右子节点的 `next` 应指向节点的 `next` 的左子节点。
4. **递归过程**: 递归地对每个节点的左右子树调用此过程，首先连接左右子树内部的节点，然后连接左子树的右侧与右子树的左侧。
5. **递归终止条件**: 当到达叶子节点时停止递归。

---