[673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence)

[ChatGPT](https://chat.openai.com/share/19576ab5-3b43-4471-b379-1b75a6853f2b)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个未排序的整数数组，找到最长递增子序列的个数。递增子序列是数组中一组数字的序列，这些数字按顺序排列，且每个数字都小于后一个数字。

**1.2 示例**：
**示例 1:**
- 输入: `[1,3,5,4,7]`
- 输出: `2`
- 解释: 最长递增子序列有 `[1, 3, 5, 7]` 和 `[1, 3, 4, 7]`，长度都是4。

**示例 2:**
- 输入: `[2,2,2,2,2]`
- 输出: `5`
- 解释: 最长递增子序列只有 `[2]`，但是存在5个相同的，所以返回5。

**1.3 提示**:
- 输入数组的长度在 `[1, 2000]` 范围内。
- 每个整数的值在 `[-10^9, 10^9]` 范围内。

## 2. 边界情况和约束
### 边界情况
1. 数组只有一个元素时，最长递增子序列的长度为1，个数也为1。
2. 所有元素相同，此时每个元素自身构成一个递增子序列，个数为数组长度。
3. 数组元素完全递增或递减。
4. 数组元素为整数极值。

### 约束
- 需要考虑大规模数组处理，确保算法效率。
- 必须处理任何可能的整数输入。

## 3. 算法和策略
### 算法设计
使用动态规划：
- 定义 `lengths[i]` 为以第 `i` 个元素结尾的最长递增子序列的长度。
- 定义 `counts[i]` 为以第 `i` 个元素结尾的最长递增子序列的个数。
- 初始化：每个元素至少可以单独成为一个递增子序列，所以 `lengths[i] = 1`，`counts[i] = 1`。
- 遍历数组，对于每个 `i`，再遍历 `0` 到 `i-1` 的元素 `j`，如果 `nums[j] < nums[i]`：
  - 如果 `lengths[j] + 1 > lengths[i]`，则更新 `lengths[i]` 并重置 `counts[i]` 为 `counts[j]`。
  - 如果 `lengths[j] + 1 == lengths[i]`，则增加 `counts[i]` 以包含由 `j` 衍生的子序列数量。

### 时间复杂度
- 算法的时间复杂度为 `O(n^2)`，其中 `n` 是数组长度，因为需要双层循环。

---