[39. 组合总和](https://leetcode.cn/problems/combination-sum)

[ChatGPT](https://chat.openai.com/share/6b1d272e-3fa3-4e87-88a7-c9b9bbde4469)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个无重复元素的数组 `candidates` 和一个目标数 `target`，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的数字可以无限次数地选取。

**1.2 示例**：
- 输入: candidates = [2,3,6,7], target = 7
- 输出: [[7],[2,2,3]]

- 输入: candidates = [2,3,5], target = 8
- 输出: [[2,2,2,2],[2,3,3],[3,5]]

**1.3 提示**:
- 所有数字（包括 `target`）都是正数。
- 解集不能包含重复的组合。
- **可重复选择**：`candidates` 中的元素可以被无限次选择，这意味着我们的解决方案中可以包含多个相同的数字。
- **无重复解**：虽然同一个数字可以多次选择，但是解集中不能有重复的组合。这要求我们在生成组合时需要有方法避免生成重复的组合。
- **组合而非排列**：组合的顺序不重要，[2,2,3] 和 [2,3,2] 被认为是相同的组合，仅需要考虑组合的内容。

## 2. 边界情况和约束

- **空数组**：如果输入的 `candidates` 是空数组，那么无论 `target` 为何值，结果都应该是空集，因为没有数字可以选择。
- **目标数为0**：如果 `target` 为0，唯一的解是空组合，因为没有选择任何数字就已经满足条件。
- **所有候选数字都大于目标数**：如果所有的 `candidates` 中的数字都大于 `target`，则不可能找到合适的组合。
- **递归深度**：考虑到数字可以无限选取，需要有一个方法来限制递归深度，避免无限递归。


## 3. 算法和策略
### 算法设计

1. **回溯法**：
   - 使用回溯法搜索所有可能的组合，当总和等于目标值时记录下来。
   - 为了避免重复，我们可以先对 `candidates` 进行排序，每次递归时只考虑当前位置和之后的数字。
   - 需要一个辅助函数来进行递归，该函数接受当前组合、当前总和、当前考虑的 `candidates` 的起始位置。

2. **递归细节**：
   - **基本情况**：如果当前总和等于目标值，将当前组合添加到结果中；如果当前总和大于目标值，回溯。
   - **递归步骤**：遍历 `candidates`，对于每个数字，尝试添加到当前组合中，并递归调用自身，之后撤销刚才的选择（回溯）。

3. **剪枝优化**：
   - 在递归过程中，如果当前总和加上某个候选数字已经超过目标值，那么这个数字以及之后的所有数字都不必考虑。

### 策略细节

- **排序**：先对 `candidates` 进行排序，有助于剪枝以及避免重复组合的生成。
- **回溯**：使用深度优先搜索（DFS）遍历所有可能的组合，通过回溯来撤销选择，逐步构建解集。
- **剪枝**：在递归过程中及时剪去不可能达到目标和的路径，减少不必要的计算。



- **排序**：通过对 `candidates` 进行排序，我们既优化了搜索效率（使得可以更早地剪枝），也避免了生成重复的组合。
- **深度优先搜索（DFS）与回溯**：我们使用了DFS来遍历所有可能的组合。通过添加元素到当前路径中，如果路径的总和等于目标值，则将其添加到结果列表中。如果当前路径的总和超过目标值或者所有可能的路径都已探索，我们回溯到上一步，即撤销最后一个选择，以探索其他可能的路径。
- **剪枝**：在每次递归调用前，我们检查加上当前候选数字后是否会超过目标和。如果会，就跳过当前数字及之后的所有数字，因为数组已排序，之后的数字只会更大。
- **递归**：通过递归调用 `dfs` 函数，允许我们重复选择相同的数字（通过不增加 `start` 的值），同时也探索了所有不同的选择路径。
---

