[109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree)

[ChatGPT](https://chat.openai.com/share/5d33094b-583a-452c-93db-3ded2251ad33)

---

## 1. 问题的内容
**1.1 题目描述**：
问题来自LeetCode 109，题目名为**"有序链表转换二叉搜索树"**。这个问题要求我们将一个升序链表转换为一个高度平衡的二叉搜索树（BST）。所谓高度平衡，指的是这棵树的任意节点的两个子树的高度差不超过1。这个转换过程需要保证二叉搜索树的特性：节点的左子树只包含小于当前节点的数，节点的右子树只包含大于当前节点的数，每个节点的左右子树也必须是二叉搜索树。

**1.2 示例**：
给定的有序链表：`[-10, -3, 0, 5, 9]`，

一个可能的答案是：`[0, -3, 9, -10, null, 5]`，它表示下面的高度平衡二叉搜索树：

```
      0
     / \
   -3   9
   /   /
-10  5
```

**1.3 提示**:
- 链表中的节点数在范围 `[0, 2^104]` 内
- `-10^5 <= Node.val <= 10^5`

## 2. 边界情况和约束
1. **链表长度为0**：这是最简单的边界情况，即给定的链表为空。这种情况下，我们应该返回一个空的二叉搜索树。

2. **链表长度为1**：当链表只包含一个元素时，这个元素自然成为BST的根节点，而没有左右子树。

3. **链表长度大于1**：对于长度大于1的链表，我们需要找到中间节点，这个节点将成为BST的根节点，然后递归地对左半部分和右半部分的链表执行相同的操作，以构建左右子树。

4. **链表长度是奇数还是偶数**：如果链表长度是偶数，我们有两个中间节点。在这种情况下，可以选择任何一个作为根节点，但为了保持平衡，通常选择第二个中间节点作为根节点更为合适。

5. **数值范围**：节点的值范围是`[-10^5, 10^5]`，这意味着我们的解决方案需要能够处理较大或较小的整数值。

6. **时间复杂度和空间复杂度**：考虑到链表的长度可能非常大，我们的算法应该尽可能高效，以避免超时。此外，尽管递归解决方案可能较为直观，但我们也需要考虑到递归调用的栈空间可能会影响整体的空间复杂度。


## 3. 算法和策略
为了将有序链表转换为高度平衡的二叉搜索树，我们需要一种方法来找到链表的中间节点，并使用它作为树的根节点，然后递归地对左右子链表执行同样的操作。这里介绍两种策略：**快慢指针法** 和 **转换为数组后分治法**。

### 快慢指针法:

1. **初始化快慢指针**：快指针每次移动两步，慢指针每次移动一步。当快指针到达链表末尾时，慢指针将位于链表的中间位置。

2. **找到中间节点**：使用快慢指针找到链表的中间节点。这个节点将成为BST的根节点。

3. **递归构建左右子树**：
   - 对于根节点左侧的链表，递归调用此方法来构建左子树。
   - 对于根节点右侧的链表，递归调用此方法来构建右子树。

4. **注意终止条件**：递归的终止条件是链表为空，这时应该返回`None`。

### 转换为数组后分治法:

1. **链表转数组**：首先将链表转换为数组，这样可以通过索引直接访问任何元素，便于找到中间元素。

2. **找到中间节点作为根节点**：数组的中间元素将成为BST的根节点。如果数组长度是偶数，选择中间两个元素中的任一个作为根节点。

3. **递归构建左右子树**：
   - 使用中间元素左侧的子数组递归构建左子树。
   - 使用中间元素右侧的子数组递归构建右子树。

4. **终止条件**：当子数组为空时停止递归。

### 算法选择：

- **快慢指针法**的优点是不需要额外的空间来存储数组，空间复杂度较低。但是，寻找中间节点需要遍历链表。
- **转换为数组后分治法**的优点是易于理解和实现，且可以在`O(1)`时间内访问中间元素。缺点是需要`O(N)`的额外空间来存储数组。

鉴于空间效率的考虑，我们优先考虑**快慢指针法**进行实现。

---