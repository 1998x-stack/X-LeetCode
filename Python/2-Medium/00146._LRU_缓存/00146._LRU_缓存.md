[146. LRU 缓存](https://leetcode.cn/problems/lru-cache)

[ChatGPT](https://chat.openai.com/share/6f8e4315-a473-4460-990e-5208346d2384)

---

## 1. 问题的内容
**1.1 题目描述**：
设计一个数据结构，实现一个 **LRU (最近最少使用)** 缓存机制。这个机制应该支持以下操作：

- `get(key)`：如果密钥存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
- `put(key, value)`：如果密钥不存在，请设置或插入值。当缓存达到其容量时，它应该使最近最少使用的项目无效，并且在写入新项目之前，删除最近最少使用的项目。

**1.2 示例**：
```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]

输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使密钥 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使密钥 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**1.3 提示**:
- `1 <= capacity <= 3000`
- `0 <= key <= 3000`
- `0 <= value <= 104`
- 最多调用 `3 * 104` 次 `get` 和 `put`。

## 2. 边界情况和约束
- **容量限制**：缓存容量 `capacity` 是有限的。
- **密钥范围**：密钥 `key` 的范围在 `0` 到 `3000` 之间。
- **值范围**：值 `value` 的范围在 `0` 到 `104` 之间。
- **操作次数限制**：`get` 和 `put` 操作的最大次数为 `3 * 104`。
- **最近最少使用策略**：当缓存容量满时，需要删除最近最少使用的项。

## 3. 算法和策略
1. **数据结构选择**：为了满足快速访问和更新最近使用的元素，推荐使用 **哈希表** 加 **双向链表** 的结构。哈希表支持快速查找，双向链表支持快速添加和删除元素。

2. **双向链表设计**：链表的每个节点包含 `key` 和 `value`，以及指向前一个节点和下一个节点的指针。这种结构方便在列表中添加和删除节点。

3. **哈希表设计**：哈希表的键是缓存项的键，值是指向链表中相应节点的指针。这样可以快速定位链表中的节点，实现快速访问。

4. **`get` 操作**：
   - 检查哈希表中是否存在给定的键。
   - 如果存在，将节点移动到双向链表的头部（表示最近使用）。
   - 返回节点的值。

5. **`put` 操作**：
   - 检查键是否已存在：
     - 如果存在，更新值并移动节点到双向链表头部。
     - 如果不存在，创建新的节点并添加到双向链表的头部，同时在哈希表中添加键值对。
   - 如果添加新节点后缓存容量超出限制，删除双向链表尾部的节点（最少使用的项）并在哈希表中删除相应的键。

6. **辅助函数设计**：
   - `move_to_head`：将节点移动到双向链表的头部。
   - `remove_node`：从双向链表中删除一个节点。
   - `add_node`：在双向链表的头部添加一个新的节点。
   - `pop_tail`：删除并返回双向链表尾部的节点。

7. **初始化**：初始化空的哈希表和双向链表，以及设置缓存的最大容量。

---