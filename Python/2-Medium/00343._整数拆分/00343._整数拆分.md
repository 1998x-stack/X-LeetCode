[343. 整数拆分](https://leetcode.cn/problems/integer-break)

[ChatGPT](https://chat.openai.com/share/bf196665-b12f-46c3-9785-1cd74cd4253f)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个正整数 `n`，将其拆分为 **至少两个** 正整数的和，使得这些整数的乘积最大化。返回可以获得的最大乘积。

**1.2 示例**：
- 输入: `n = 2`
- 输出: `1`
- 解释: `2 = 1 + 1`, `1 × 1 = 1`。

- 输入: `n = 10`
- 输出: `36`
- 解释: `10 = 3 + 3 + 4`, `3 × 3 × 4 = 36`。

**1.3 提示**:
- 整数 `n` 的范围是 `[2, 58]`。

## 2. 边界情况和约束
- **边界情况**:
  - 当 `n` 等于 2 或 3 时，最大乘积分别为 1 和 2，因为拆分的数不能小于 2。
  - 对于 `n > 3` 的情况，我们需要寻找更复杂的拆分策略。

- **约束**:
  - `n` 是一个正整数，范围是 `[2, 58]`。
  - 必须拆分成至少两个正整数。

## 3. 算法和策略
1. **初始化**:
   - 创建一个数组 `dp`，长度为 `n + 1`，用于存储从 1 到 `n` 每个数的最大乘积。`dp[i]` 表示数字 `i` 拆分后的最大乘积。
   - 初始化 `dp[1] = 1`（虽然题目要求至少拆分两个数，但初始化 `dp[1]` 可以简化后续逻辑）。

2. **填充 dp 数组**:
   - 从 `i = 2` 到 `n` 遍历，计算每个 `dp[i]`。
   - 对于每个 `i`，再进行一次从 `j = 1` 到 `i - 1` 的遍历，每次尝试将 `i` 拆分为 `j` 和 `i - j` 两部分，更新 `dp[i]` 为这些拆分方法中乘积最大的一个。
   - 更新 `dp[i]` 时，比较 `dp[i]` 和 `max(j * (i - j), j * dp[i - j])`，后者表示两种情况：直接将 `i` 拆分为 `j` 和 `i - j` 两数相乘，或将 `i - j` 继续拆分。

3. **返回结果**:
   - `dp[n]` 即为所求的最大乘积。

---