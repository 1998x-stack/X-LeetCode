[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements)

[ChatGPT](https://chat.openai.com/share/30efa03d-04ad-4526-8671-4b6ff11a626b)

---

## 1. 问题的内容
**1.1 题目描述**：
题目来源于[LeetCode 347](https://leetcode.cn/problems/top-k-frequent-elements)，要求从给定的非空整数数组中找出出现频率前 **k** 高的元素。需要注意的是，答案可以以任意顺序返回。

关键点：
- 数组中的整数可以是重复的。
- **k** 的值有效，即 `1 <= k <= 数组中不同元素的数量`。

**1.2 示例**：
假设有一个数组 `[1,1,1,2,2,3]` 和 `k = 2`，那么前 **k** 个高频元素就是 `[1,2]`，因为 `1` 出现了三次，`2` 出现了两次，它们是出现频率最高的两个元素。

**1.3 提示**:
- 数组不为空，并且 **k** 的值总是有效的。
- 可能有多种方法来解决这个问题，包括使用堆（优先队列）、桶排序或哈希表等。

## 2. 边界情况和约束
- 数组长度为1时，无论 **k** 的值为多少，只能返回数组中唯一的元素。
- 当所有元素的出现频率都不相同时，前 **k** 个高频元素将是出现频率最高的 **k** 个元素。
- 当多个元素有相同的出现频率，且这些频率属于前 **k** 高的情况下，任意选择这些元素作为结果都是可接受的。

## 3. 算法和策略
1. **使用哈希表统计频率**：
   - 遍历数组，使用哈希表记录每个元素出现的次数。

2. **利用优先队列（堆）找出前 k 高频元素**：
   - 根据元素频率构建一个最小堆，堆的大小保持在 **k**。
   - 遍历哈希表，对于每个元素，如果堆的大小小于 **k**，就添加到堆中。
   - 如果堆的大小等于 **k** 且当前元素的频率大于堆顶元素的频率，则弹出堆顶元素，将当前元素添加到堆中。
   - 这样，堆中始终保持频率最高的 **k** 个元素。

3. **提取结果**：
   - 堆中的元素即为前 **k** 个高频元素。

---