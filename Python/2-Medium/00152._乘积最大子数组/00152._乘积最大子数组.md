[152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray)

[ChatGPT](https://chat.openai.com/share/db2db87b-af71-4ff4-beed-93f97cb569a0)

---

## 1. 问题的内容
**1.1 题目描述**：
  - 给定一个整数数组`nums`，找出数组中乘积最大的连续子数组（该子数组至少包含一个数字），返回该子数组对应的乘积。

**1.2 示例**：
  - 示例 1：
    - 输入: `nums = [2,3,-2,4]`
    - 输出: `6`
    - 解释: 子数组 `[2,3]` 有最大乘积 `6`。
  - 示例 2：
    - 输入: `nums = [-2,0,-1]`
    - 输出: `0`
    - 解释: 结果不能为 `2`，因为 `[-2,-1]` 不是子数组。

**1.3 提示**:
  - `0 <= nums.length <= 2 * 10^4`
  - `-10 <= nums[i] <= 10`
  - 数组的任何元素都可以是子数组的起点或终点。

## 2. 边界情况和约束
- **边界情况**：
  - 空数组：`nums` 长度为 `0`。
  - 单个元素数组：`nums` 长度为 `1`。
  - 全部正数或全部负数的数组。
  - 包含零的数组。

- **约束**：
  - 数组长度的限制：`0 <= nums.length <= 2 * 10^4`。
  - 元素值的范围：`-10 <= nums[i] <= 10`。

## 3. 算法和策略
- **核心思想**：
  - 动态规划：追踪到当前位置为止的最大乘积和最小乘积（考虑到负负得正的情况）。

- **步骤**：
  1. 初始化两个变量，分别用来存储到当前位置为止的最大乘积`maxProd`和最小乘积`minProd`，初始值均为`nums[0]`，以及全局最大乘积`globalMax`也设为`nums[0]`。
  2. 从数组的第二个元素开始遍历，对于每个元素`nums[i]`：
     - 计算包含当前元素的最大乘积和最小乘积，由于当前数可以是正也可以是负，所以最大值可以从以下三者中产生：
       - 前一个位置的最大乘积与当前数的乘积`maxProd * nums[i]`
       - 前一个位置的最小乘积与当前数的乘积（负负得正的情况）`minProd * nums[i]`
       - 当前数自身`nums[i]`（断开前面的乘积，自成一段）
     - 更新`maxProd`和`minProd`。
  3. 每遍历到一个新元素，都比较并更新全局最大乘积`globalMax`。
  4. 遍历完成后，`globalMax`即为所求的乘积最大子数组的乘积。

### **细节处理**：

- 处理包含零和负数的情况，尤其是连续负数的情况，需要同时追踪最大乘积和最小乘积。
- 确保遍历时考虑到只包含单个元素的子数组。

---