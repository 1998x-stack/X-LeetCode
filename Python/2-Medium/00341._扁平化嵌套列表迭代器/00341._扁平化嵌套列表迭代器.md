[341. 扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator)

[ChatGPT](https://chat.openai.com/share/16ea4f04-30c1-4f97-9d24-41248f925879)

---

## 1. 问题的内容
**1.1 题目描述**：
题目要求实现一个迭代器，该迭代器能够遍历一个嵌套的列表。这个嵌套列表可能包含整数或者是其他嵌套列表，我们需要将其展开为一个由所有整数构成的平坦列表，并按顺序遍历。

**1.2 示例**：
例如，给定列表 `[[1,1],2,[1,1]]`，迭代器应当返回 `1, 1, 2, 1, 1`。给定列表 `[1,[4,[6]]]`，迭代器应当返回 `1, 4, 6`。

**1.3 提示**:
- 嵌套可以是多层的，即列表中的列表可以再包含列表。
- 要求实现 `next()` 和 `hasNext()` 方法，其中 `next()` 方法在每次调用时返回平坦列表中的下一个整数，`hasNext()` 方法用来检查是否还有更多的整数可以返回。
- **嵌套的复杂度**: 需要能处理任意层级的嵌套。
- **迭代器实现**: 实现迭代器接口，需要保持状态，以便于每次调用 `next()` 方法时能返回正确的元素。
- **延迟加载**: 仅在需要时才展开嵌套的元素，这样可以提高效率，特别是在嵌套结构非常大时。

## 2. 边界情况和约束
**边界情况**:

- **空的嵌套列表**: 迭代器应能处理空列表的情况，即在这种情况下 `hasNext()` 返回 `false`。
- **嵌套列表中的空列表**: 应正确跳过空列表，不影响遍历结果。
- **多层空列表嵌套**: 例如 `[[], [[], []]]`，同样应当正确处理，视为没有任何元素。

**约束**:

- **空间复杂度**: 应尽量减少额外使用的空间，优先考虑在遍历时逐步解开嵌套结构，而非一开始就完全展开。
- **时间复杂度**: `next()` 和 `hasNext()` 方法的调用应尽可能高效。

## 3. 算法和策略
1. **使用栈**: 栈可以帮助我们以非递归的方式解开嵌套的列表。我们可以将所有元素（包括嵌套列表）以反向的顺序压入栈中，这样可以保证我们在弹出元素时，元素的顺序是正确的。

2. **延迟解嵌套**: 我们可以在调用 `next()` 方法时才解嵌套，这样可以实现延迟加载，避免一开始就处理整个嵌套结构。

3. **迭代器方法实现**:
   - `hasNext()`: 检查栈是否为空。如果栈顶是一个列表，则需要解嵌套直到栈顶是一个整数或栈为空。
   - `next()`: 返回栈顶的整数，并弹出。如果栈顶是一个列表，先进行解嵌套操作。

---