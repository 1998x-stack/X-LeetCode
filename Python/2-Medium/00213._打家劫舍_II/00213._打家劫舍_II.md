[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii)

[ChatGPT](https://chat.openai.com/share/a8cd6339-531c-4aef-b124-d8ca24b767c5)

---

## 1. 问题的内容
**1.1 题目描述**：
- **题目链接**: [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii)
- **问题描述**: 给定一个代表每个房屋存放金额的非负整数数组，这些房屋围成一圈。这意味着第一个房屋和最后一个房屋是相邻的。一个小偷计划偷窃这个街区的房屋，但他不允许同时偷窃相邻的两个房屋。问在不触动警报的情况下，他最多能偷到多少钱？

**1.2 示例**：
- **输入**: `nums = [2,3,2]`
- **输出**: `3`
- **解释**: 因为第一个房屋和最后一个房屋是相邻的，所以不能同时偷窃第一个房屋和最后一个房屋，偷窃第二个房屋得到的金额最多。

**1.3 提示**:
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

## 2. 边界情况和约束
1. **如何处理环形的约束？**
   - 分别计算“不包括第一个房屋”和“不包括最后一个房屋”的最大收益，然后取两者的最大值。
   
2. **动态规划的状态转移方程是什么？**
   - 设`dp[i]`为到达第`i`个房屋时能偷窃到的最大金额，状态转移方程为`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`。

- 当`nums`长度为`1`时，只有一个房屋可偷，直接返回该房屋的金额。
- 当`nums`长度为`2`时，由于房屋形成环状，只能偷窃其中的一个房屋，返回金额较大的一个。

## 3. 算法和策略
1. **处理特殊情况**：如果数组长度为`1`或`2`，直接处理返回结果。
2. **定义子问题**：将原问题分解为两个子问题，一个是不包括第一个房屋，另一个是不包括最后一个房屋。
3. **设计动态规划算法**：
   - 初始化两个dp数组，一个用于保存包括第一个房屋到倒数第二个房屋的最大金额，另一个用于保存从第二个房屋到最后一个房屋的最大金额。
   - 遍历每个子数组，根据动态规划的状态转移方程更新dp数组。
   - 返回两个子问题的最大值作为最终结果。
4. **状态转移方程**：`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`，其中`i`表示当前房屋的索引，`dp[i-1]`表示不偷当前房屋的最大金额，`dp[i-2] + nums[i]`表示偷当前房屋的最大金额。
5. **边界条件处理**：`dp[0]`为第一个房屋的金额（对于第二个子问题是0），`dp[1]`为第一个房屋和第二个房屋中金额较大的一个。

---