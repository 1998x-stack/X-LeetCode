[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal)

[ChatGPT](https://chat.openai.com/share/12bb80a1-243d-4c17-90d7-b348454d46c0)

---

## 1. 问题的内容
**1.1 题目描述**：
- 根据给定的二叉树的中序遍历和后序遍历的结果，重建这棵二叉树。

**1.2 示例**：
- 假设有中序遍历 `[9,3,15,20,7]` 和后序遍历 `[9,15,7,20,3]`，我们需要根据这两个序列重建原始的二叉树。

**1.3 提示**:
- 二叉树中每个节点的值都不相同。
- 中序遍历的序列中，某个节点的左侧子树的值会先被访问，然后是当前节点的值，最后是右侧子树的值。
- 后序遍历的序列中，某个节点的左右子树的值会先被访问，最后是当前节点的值。

## 2. 边界情况和约束
**边界情况**:
1. **空树**: 如果给定的中序和后序遍历序列都为空，则树也为空。这是递归终止的一个基本条件。
2. **单节点树**: 如果序列中只有一个元素，那么这棵树只有一个节点。
3. **非平衡树**: 树可能是高度非平衡的，即所有节点都倾斜向一侧，这将是测试我们解决方案健壮性的一个好例子。

**约束条件**:
1. **唯一性**: 二叉树中的每个节点都具有唯一的值。这意味着我们可以使用节点的值作为它们的唯一标识符。
2. **无重复值**: 由于树中的每个值都是唯一的，我们不需要担心如何处理重复值的情况。
3. **正确的输入序列**: 假设提供的中序和后序遍历序列是正确的，即它们确实代表了某个有效的二叉树的遍历结果。


## 3. 算法和策略

### 算法概述:

1. **使用后序遍历确定根节点**: 在后序遍历中，最后一个元素总是树的根节点。这意味着我们可以从后序遍历的最后一个元素开始，确定树的根节点。

2. **在中序遍历中定位根节点**: 一旦我们知道了根节点的值，我们就可以在中序遍历的序列中找到这个值的位置。这个位置将中序序列分割成两个部分：左侧部分是树的左子树，右侧部分是树的右子树。

3. **递归构造左右子树**: 使用中序遍历和后序遍历的相应部分递归地构造左子树和右子树。对于每个子树，重复步骤1和2。

### 算法详细步骤:

- **初始化**:
    - 创建一个哈希表，以存储中序遍历中所有值的索引，以便快速查找。
    - 定义递归函数，用于根据中序和后序遍历的某个部分构造子树。

- **递归函数**:
    - **输入参数**: 中序遍历的起始和结束索引，后序遍历的起始和结束索引。
    - **递归终止条件**: 如果起始索引大于结束索引，说明子树为空，返回None。
    - **找到根节点并构造**: 从后序遍历的末尾取出根节点的值，根据这个值在哈希表中找到该值在中序遍历中的索引。使用这个索引将中序遍历分割为左右两个部分，分别对应左右子树。
    - **递归构造左子树**: 调用递归函数，传入左子树对应的中序和后序遍历的索引范围。
    - **递归构造右子树**: 调用递归函数，传入右子树对应的中序和后序遍历的索引范围。
    - **返回构造的节点**: 创建一个新的树节点，其左右子节点分别是递归构造左右子树的返回结果。

---