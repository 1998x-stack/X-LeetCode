[713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k)

[ChatGPT](https://chat.openai.com/share/d938b7f9-befc-4b3a-98c5-37458a2ea466)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个正整数数组 `nums` 和一个正整数 `k`，求出乘积小于 `k` 的连续子数组的个数。

**1.2 示例**：
输入：`nums = [10, 5, 2, 6]`, `k = 100`
输出：`8`
解释：有 8 个子数组的乘积小于 100：
- `[10]`, `[5]`, `[2]`, `[6]`
- `[10, 5]`, `[5, 2]`, `[2, 6]`
- `[5, 2, 6]`

**1.3 提示**:
- `1 <= nums.length <= 3 * 10^4`
- `1 <= nums[i] < 1000`
- `0 < k <= 10^6`

## 2. 边界情况和约束
边界情况：
- `nums` 数组只有一个元素，且这个元素小于 `k`。
- 所有元素的乘积仍小于 `k`。
- 所有元素的乘积都大于 `k`。

约束：
- `nums` 的元素都是正整数，因此不需要考虑负数或零的情况。

## 3. 算法和策略
#### 算法策略
使用**滑动窗口（双指针）**方法，通过移动窗口的开始和结束位置来找出所有乘积小于 `k` 的子数组。

**算法步骤**：
1. 初始化两个指针 `start` 和 `end`，都指向数组的开始位置。
2. 初始化 `current_product` 为 1，表示当前窗口内的元素乘积。
3. 遍历数组，通过 `end` 指针扩展窗口：
   - 更新 `current_product` 为窗口内元素的乘积。
   - 当 `current_product` 大于或等于 `k` 时，移动 `start` 指针缩小窗口，直到 `current_product` 小于 `k`。
   - 每当 `current_product` 小于 `k` 时，计算当前 `end` 位置能贡献的子数组数量，即 `end - start + 1`。
4. 返回所有满足条件的子数组数量。

---