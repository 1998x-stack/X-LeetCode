[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence)

[ChatGPT](https://chat.openai.com/share/a0cdb14b-2552-458c-ba00-840ab55a9390)

---

## 1. 问题的内容
**1.1 题目描述**：
摆动序列是指一个序列中的数字被替换成两个符号`↑`和`↓`后，这些符号交替出现。例如，序列`[1, 7, 4, 9, 2, 5]`是一个摆动序列，因为差值`(6, -3, 5, -7, 3)`可以被简化成`↑↓↑↓↑`。

一个小于2的序列显然是摆动序列。给定一个整数序列，返回这个序列作为摆动序列的最长子序列的长度。子序列可以通过从原始序列中删除一些（也可以不删除）元素得到，但保留剩余元素的相对顺序。

**1.2 示例**：
- **输入**: `[1,7,4,9,2,5]`
- **输出**: `6`
- 解释: 整个序列是一个摆动序列。

- **输入**: `[1,17,5,10,13,15,10,5,16,8]`
- **输出**: `7`
- 解释: 子序列`[1,17,10,13,10,16,8]`是一个摆动序列。

- **输入**: `[1,2,3,4,5,6,7,8,9]`
- **输出**: `2`
- 解释: 最长摆动子序列为`[2,3]`或者任何两个连续的数字，因为差值是正的，没有`↑↓`交替出现的模式。

**1.3 提示**:
- 给定序列的长度在`0`到`1000`之间。
- 序列中的所有数字都在`-2^31`到`2^31 - 1`之间。

## 2. 边界情况和约束
1. **序列长度为0或1**:
   - 当序列长度为0时，显然没有摆动序列，应返回0。
   - 当序列长度为1时，可以视为摆动序列的最简形式，返回1。

2. **所有数字相同**:
   - 如果序列中所有数字相同，则不存在摆动，因为没有↑或↓的变化，应返回1，因为任何单一元素都可以被视为一个摆动序列。

3. **连续相同的数字**:
   - 连续出现的相同数字对摆动序列的长度没有贡献，因为它们不会增加↑或↓的变化。在分析时，应该跳过这些重复数字，只考虑变化的点。

4. **序列长度极大**:
   - 给定的序列长度可能达到1000，这要求算法必须足够高效，以在合理的时间内处理大量数据。

5. **数字范围**:
   - 数字范围在`-2^31`到`2^31 - 1`之间，算法设计时需要考虑整型溢出的问题。

#### **约束**:

- 输入序列长度范围：\[0, 1000\]。
- 输入序列中的数字范围：\[-2^31, 2^31 - 1\]。

## 3. 算法和策略
#### **贪心算法设计**:

**目标**：在遍历序列的过程中，持续更新摆动序列的最大长度。

**策略**：
- 初始化两个计数器`up`和`down`，分别代表以当前数字结尾，最后一个差值为正（↑）或负（↓）时的摆动序列的最大长度。初始值均设为1（序列长度为1时，认为既可以向上摆动也可以向下摆动）。
- 从第二个元素开始遍历序列，对于每一个元素，比较它与前一个元素的差值。
  - 如果当前元素比前一个元素大，则更新`up`计数器为`down + 1`，表示当前元素可以在任何以负差值结束的序列后形成摆动序列。
  - 如果当前元素比前一个元素小，则更新`down`计数器为`up + 1`，表示当前元素可以在任何以正差值结束的序列后形成摆动序列。
- 遍历完整个序列后，摆动序列的最大长度为`up`和`down`中的最大值。

#### **详细步骤**:

1. **初始化**:
   - `up = 1, down = 1`：起始时，序列的最大长度至少为1。

2. **遍历序列**:
   - 对于序列中的每个元素`nums[i]`（从`i=1`开始，即第二个元素）：
     - 如果`nums[i] > nums[i-1]`，则`up = down + 1`。
     - 如果`nums[i] < nums[i-1]`，则`down = up + 1`。
   - 对于`nums[i] == nums[i-1]`的情况，不做任何操作，因为连续的相同元素不影响摆动序列的长度。

3. **计算最终结果**:
   - 最大摆动序列长度为`max(up, down)`。

#### **算法复杂度**:
- 时间复杂度：O(n)，只需要遍历一次序列。
- 空间复杂度：O(1)，只使用了有限的额外空间。

---