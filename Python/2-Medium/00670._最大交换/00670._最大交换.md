[670. 最大交换](https://leetcode.cn/problems/maximum-swap)

[ChatGPT](https://chat.openai.com/share/e61b97d2-1d25-47ff-92bd-601b18aa47ae)

---

## 1. 问题的内容
**1.1 题目描述**：
在 [LeetCode 670. 最大交换](https://leetcode.cn/problems/maximum-swap) 的问题中，给定一个非负整数，你可以选择交换一次数字中的两个数位，使得所得到的新整数尽可能大。如果整数已经是最大的，则返回原整数。

**1.2 示例**：
- **输入**：2736
- **输出**：7236
- **解释**：交换数字2和数字7。

- **输入**：9973
- **输出**：9973
- **解释**：此数已是最大，不需交换。

**1.3 提示**:
1. 数字的长度范围为 2 至 8。
2. 题目保证给定的数字是有效的非负整数。

## 2. 边界情况和约束
### 边界情况

1. 数字长度为 2，即最小长度的情况。
2. 数字长度为 8，即最大长度的情况。
3. 所有数字均相同，如1111。
4. 数字已是最大排列，如98765432。

### 约束条件

1. 需要在一次交换中实现最大化数字。
2. 数字的交换不应该改变数字的总长度。

## 3. 算法和策略
### 算法描述

我们的目标是尽量让高位的数字更大。算法的核心是从右向左扫描数字，寻找可能的最大数字和它应该替换的较小的数字。

1. **记录每个数字最后出现的位置**：这有助于我们在需要交换时快速定位。
2. **从左到右遍历数字**，对于每个位置，检查是否存在一个大于当前数字且位置在当前数字右侧的数字。这是一个潜在的最佳交换选择。
3. **执行交换**：找到第一个这样的机会即执行交换，并返回结果。

### 步骤细化

1. 将整数转换为数字列表。
2. 从右到左遍历这个列表，用一个数组记录每个数字最后一次出现的位置。
3. 从左到右遍历数字，对于每个数字，检查是否有比它大且位置靠后的数字。
4. 如果找到，进行交换并立即返回新的整数。
5. 如果遍历完成未找到交换机会，则返回原整数。

---