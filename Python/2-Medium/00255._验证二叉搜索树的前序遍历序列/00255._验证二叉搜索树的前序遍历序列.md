[255. 验证二叉搜索树的前序遍历序列](https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree)

[ChatGPT](https://chat.openai.com/share/003efd0f-a194-4691-aa7b-d643a43dd6ed)

---

## 1. 问题的内容
**1.1 题目描述**：
- 给定一个整数数组，判断该数组是否表示某个二叉搜索树的前序遍历序列。

**二叉搜索树的特点**：
- 任一节点的左子树只包含小于当前节点的数。
- 任一节点的右子树只包含大于当前节点的数。
- 任一节点的左右子树也分别为二叉搜索树。

**1.2 示例**：
- 输入: [5,2,6,1,3] 
- 输出: False
- 解释: 给定的序列对应的二叉搜索树为：
  ```
     5
    / \
   2   6
  / \
 1   3
  ```
  显然，这不是一个二叉搜索树的前序遍历序列。

- 输入: [5,2,1,3,6]
- 输出: True
- 解释: 给定的序列对应的二叉搜索树为：
  ```
     5
    / \
   2   6
    \
     3
    /
   1
  ```
  这是一个二叉搜索树的前序遍历序列。

**1.3 提示**:
- 本题的关键是理解二叉搜索树的前序遍历序列的特点。
- 前序遍历的顺序为“根-左-右”，对于二叉搜索树而言，这意味着序列的第一个元素为根节点，接下来是比根节点小的所有元素（左子树），然后是比根节点大的所有元素（右子树）。
- 重点在于如何判断序列是否满足这样的分布，同时保证左子树和右子树也分别满足二叉搜索树的条件。

## 2. 边界情况和约束
**边界情况**：
- 数组为空，理论上应返回True，因为空数组不违反二叉搜索树的定义。
- 数组只有一个元素，同样返回True。
- 数组中包含重复元素，在二叉搜索树中是不允许的，但题目没有明确说明如何处理，假设本题允许重复元素存在。

**约束**：
- 整数数组的长度和元素大小。题目未明确给出，但应考虑到实际情况下的内存和时间效率问题。

## 3. 算法和策略
**算法设计**：
1. 使用栈模拟二叉搜索树的构建过程。
2. 遍历数组，对于每个元素，将其视为当前的根节点。
3. 如果栈不空，且栈顶元素小于当前元素，说明当前元素应位于栈顶元素的右子树中。此时，连续弹出栈顶元素，直到栈顶元素大于当前元素，记录最后一个弹出的元素为上一个根节点，以确保当前元素放置在正确的位置。
4. 将当前元素压入栈中。
5. 使用一个变量记录上一个根节点的值，如果下一个元素小于这个值，返回False，因为这违反了二叉搜索树的定义。
6. 如果整个数组遍历完成都没有违反二叉搜索树的条件，返回True。

**策略细节**：
- 使用栈来保存已遍历的节点，模拟二叉树的构建过程。
- 利用二叉搜索树左子树小于根节点，右子树大于根节点的特性进行判断。
- 需要维护一个“上一个根节点”的值，以确保当前节点放在正确的位置。

---