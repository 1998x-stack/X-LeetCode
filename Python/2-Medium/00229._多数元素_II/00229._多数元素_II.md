[229. 多数元素 II](https://leetcode.cn/problems/majority-element-ii)

[ChatGPT](https://chat.openai.com/share/d7cb118f-fb93-4930-8775-847b3f44eb7b)

---

## 1. 问题的内容
**1.1 题目描述**：
问题来源于 LeetCode 229，题目名为“多数元素 II”。题目要求我们在一个大小为 n 的数组中找出所有出现超过 ⌊ n/3 ⌋ 次的元素。题目保证算法的时间复杂度为 O(n)，并且空间复杂度为 O(1)。

**1.2 示例**：
- 示例 1:
  - 输入: nums = [3,2,3]
  - 输出: [3]

- 示例 2:
  - 输入: nums = [1]
  - 输出: [1]

- 示例 3:
  - 输入: nums = [1,2]
  - 输出: [1,2]

**1.3 提示**:
1. 1 <= nums.length <= 5 * 10^4
2. -10^9 <= nums[i] <= 10^9

## 2. 边界情况和约束
1. **边界情况**：
   - 数组长度为 1 或 2，这时数组中所有元素均可能是答案。
   - 所有元素都相同，那么这个相同的元素就是答案。
   - 不存在任何一个元素的出现次数超过 ⌊ n/3 ⌋。在这种情况下，应返回空数组。

2. **约束**：
   - 时间复杂度必须为 O(n)，意味着我们不能使用双重循环等方法。
   - 空间复杂度为 O(1)，排除了使用额外空间来存储每个元素出现次数的方法。

## 3. 算法和策略
1. **摩尔投票法扩展**：
   - 根据题意，出现次数超过 ⌊ n/3 ⌋ 的元素最多只能有两个。
   - 我们可以维护两个候选者和它们的计票数。遍历数组，进行以下操作：
     - 如果当前元素与第一个候选者相同，第一个计票数加一。
     - 如果当前元素与第二个候选者相同，第二个计票数加一。
     - 如果第一个计票数为零，将当前元素设为第一个候选者，并计一票。
     - 如果第二个计票数为零，将当前元素设为第二个候选者，并计一票。
     - 如果当前元素既不是第一个候选者也不是第二个候选者，同时减少两个候选者的计票数。
   - 遍历完成后，我们得到了两个候选者。但这并不意味着他们的出现次数一定超过 ⌊ n/3 ⌋，需要再次遍历数组以确认。
2. **确认候选者**：
   - 对于摩尔投票法选出的两个候选者，我们需要重新计算它们在数组中的出现次数。
   - 如果候选者的出现次数超过 ⌊ n/3 ⌋，则将其加入结果列表。

---