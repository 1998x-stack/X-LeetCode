[46. 全排列](https://leetcode.cn/problems/permutations)

[ChatGPT](https://chat.openai.com/share/4144c35f-581d-45b4-8052-26d856ff0ee)

---

## 1. 问题的内容
**1.1 题目描述**：

题目链接：[46. 全排列](https://leetcode.cn/problems/permutations)  
问题描述：给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。你可以按任意顺序返回答案。

**1.2 示例**：
- 输入示例：`nums = [1,2,3]`
- 输出示例：`[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]`

**1.3 提示**:
- 输入数组不含重复数字。
- 要求返回所有可能的全排列。

## 2. 边界情况和约束
#### 2.1 确定输入范围和类型

- **输入范围**：题目未特别指明数组的大小限制，但考虑到全排列的复杂度，输入数组的大小将直接影响算法的可行性和性能。一般情况下，数组大小不宜过大。
- **输入类型**：整数数组，不含重复数字。

#### 2.2 分析可能的边界条件和特殊情况

- **空数组**：输入数组为空时，应返回一个空的列表，因为没有元素可以排列。
- **单元素数组**：只有一个元素的数组，全排列只有一个，即其自身。
- **小数组**：对于较小的数组（例如，2-4个元素），可以手动验证算法的正确性。
- **大数组**：随着数组大小的增加，全排列的数量急剧增加，需考虑算法的时间和空间复杂度。


## 3. 算法和策略

1. **初始化**：创建一个空列表来存储所有可能的排列。
2. **递归函数设计**：
   - **参数**：当前的排列 `path`，可选的数字列表 `options`。
   - **终止条件**：当 `options` 为空时，将 `path` 添加到结果列表中。
   - **遍历**：对于 `options` 中的每个数字，将其添加到 `path` 中，并从 `options` 中移除，然后递归调用。
   - **回溯**：递归完成后，将上一步加入 `path` 的数字移除，恢复 `options`，以尝试下一个数字。
3. **调用递归函数**：从一个空的 `path` 和完整的 `options` （即输入数组）开始递归。

- **时间复杂度**：由于需要生成所有可能的排列，所以时间复杂度为 \(O(n!)\)，其中 \(n\) 是数组的长度。
- **空间复杂度**：主要由递归栈和存储结果的列表构成，最坏情况下空间复杂度为 \(O(n \cdot n!)\)，用于存储 \(n!\) 个排列，每个长度为 \(n\)。
---

