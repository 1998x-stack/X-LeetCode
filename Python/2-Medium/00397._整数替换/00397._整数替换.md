[397. 整数替换](https://leetcode.cn/problems/integer-replacement)

[ChatGPT](https://chat.openai.com/share/362b7962-ddb1-481a-9e2c-ce0bd9bfaffa)

---

## 1. 问题的内容
**1.1 题目描述**：
题目[397. 整数替换](https://leetcode.cn/problems/integer-replacement)要求对一个正整数`n`进行操作，直到`n`变为1。操作规则如下：
1. 如果`n`是偶数，则用`n / 2`替换`n`。
2. 如果`n`是奇数，则可以用`n + 1`或`n - 1`替换`n`。

题目的目标是找出使`n`变为1所需的最小替换次数。

**1.2 示例**：
- 输入：`n = 8`
- 输出：`3`
- 解释：`8 -> 4 -> 2 -> 1`

- 输入：`n = 7`
- 输出：`4`
- 解释：`7 -> 8 -> 4 -> 2 -> 1` 或 `7 -> 6 -> 3 -> 2 -> 1`

**1.3 提示**:
- 题目保证给定的`n`满足`1 <= n <= 2^31 - 1`。

## 2. 边界情况和约束
#### 边界情况：
1. **最小输入值**：`n = 1`时，无需任何操作，直接返回`0`。
2. **偶数**：直接除以2，操作非常直接，不需要额外的决策。
3. **大整数**：输入值接近`2^31 - 1`时，操作过程中数值可能会超过整数的常规处理范围，需要考虑到整数溢出的问题。

#### 约束：
1. 输入值`n`的范围为`1 <= n <= 2^31 - 1`，意味着我们需要考虑到整数的最大值问题。
2. 对于奇数的处理，需要选择`n + 1`或`n - 1`。理想的选择是使得后续操作次数最少的那个，这需要一定的逻辑来判断。
3. 递归或迭代的深度。由于我们不知道需要多少步骤可以将`n`减至1，实现时需要考虑递归或迭代深度可能会很大的问题。

## 3. 算法和策略
#### 算法设计（递归）：
1. **基础情况**：如果`n`为1，不需要任何操作，返回0。
2. **偶数情况**：如果`n`是偶数，直接对`n / 2`应用递归，并将结果加1。
3. **奇数情况**：如果`n`是奇数，需要比较`n + 1`和`n - 1`转变为1所需的步骤数。由于直接计算可能导致重复计算，我们可以考虑使用备忘录来存储已计算的结果。

#### 算法优化（备忘录递归）：
- 使用一个哈希表作为备忘录，存储每个计算过的`n`对应的最小操作次数。
- 在递归前先检查备忘录，如果结果已知，则直接返回结果，避免重复计算。

#### 特殊策略对于奇数的处理：
- 对于奇数`n`，我们需要决定是加1好还是减1好。一般情况下，如果`n + 1`或`n - 1`能被4整除，则优先选择，因为它可以更快地减少到更小的偶数。

根据上述分析和设计，下一步将是根据这个策略实现代码，并对关键步骤进行注释。

根据我们的实现和测试结果：
- 当`n = 8`时，最小替换次数为`3`，符合预期。
- 当`n = 7`时，最小替换次数为`4`，符合预期。
- 我们还额外测试了一个案例，`n = 3`，其结果为`2`，同样符合预期。

这验证了我们的算法和代码实现的正确性。接下来，我们将进行代码的逻辑和正确性复查，确保没有遗漏任何关键部分或边界条件。

---