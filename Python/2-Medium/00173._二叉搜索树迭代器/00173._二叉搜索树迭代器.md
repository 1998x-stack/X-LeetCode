[173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator)

[ChatGPT](https://chat.openai.com/share/75748e52-d59e-41dd-921f-0afe05bff431)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode 173题“二叉搜索树迭代器”要求设计一个二叉搜索树迭代器类，它应该支持以下功能：

- `next()`：返回二叉搜索树中的下一个最小的数。
- `hasNext()`：返回二叉搜索树中是否还有下一个更小的数。

这个迭代器会以递增顺序访问二叉搜索树(BST)的所有节点，模拟中序遍历的过程。中序遍历的特点是先访问左子树，然后访问根节点，最后访问右子树。对于BST，这意味着所有节点会按照从小到大的顺序被访问。

**1.2 示例**：
假设有一个二叉搜索树，其结构如下：

```
   7
  / \
 3   15
    /  \
   9    20
```

迭代器初始化后，中序遍历的顺序是 `[3, 7, 9, 15, 20]`。

调用 `next()` 返回 3，`hasNext()` 返回 `True`，再次调用 `next()` 返回 7，以此类推。

**1.3 提示**:
- 你可以假设 `next()` 调用总是合理的，即当调用 `next()` 时，BST 中至少存在一个下一个最小的数。

## 2. 边界情况和约束
- **空树**：当树为空时，`hasNext()` 应该返回 `False`，而 `next()` 不会被调用。
- **只有一个节点的树**：在这种情况下，`next()` 将返回唯一的节点值，之后 `hasNext()` 应返回 `False`。
- **完全二叉树或不平衡树**：迭代器应能正确处理所有类型的二叉搜索树，无论其平衡与否。

## 3. 算法和策略
1. **初始化**：
   - 使用一个栈来存储从根节点到最左侧节点的路径。这个路径包含了待访问的所有节点，最顶端的节点是下一个最小的节点。

2. **`next()` 方法**：
   - 弹出栈顶元素，这是当前的最小节点。
   - 将这个节点的右子节点及其所有左子节点推入栈中。这一步模拟了中序遍历中访问右子树的过程。
   - 返回被弹出节点的值。

3. **`hasNext()` 方法**：
   - 简单地检查栈是否为空。如果栈不为空，表示还有更多节点待访问，因此返回 `True`；否则，返回 `False`。

---