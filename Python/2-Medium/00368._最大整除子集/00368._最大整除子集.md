[368. 最大整除子集](https://leetcode.cn/problems/largest-divisible-subset)

[ChatGPT](https://chat.openai.com/share/06ec7e05-2557-47f0-aab8-83c0943d8a52)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode 368题，**最大整除子集**，要求找出一个集合中最大的整除子集，这个子集中的每个元素都必须是集合中某个其他元素的因子（或者被其他元素整除），这里的"最大"是指子集的元素数量最多。

**1.2 示例**：
- **输入**：nums = [1,2,3]
- **输出**：[1,2] 或 [1,3]

在这个例子中，[1,2] 和 [1,3] 都是有效的最大整除子集，因为2是1的倍数，3也是1的倍数。

- **输入**：nums = [1,2,4,8]
- **输出**：[1,2,4,8]

这个例子中，[1,2,4,8] 是最大整除子集，因为每个数字都是前一个数字的倍数。

**1.3 提示**:
- 集合中的元素范围是 [1, 2, ... , 1000]。
- 集合的大小不超过 1000。

## 2. 边界情况和约束
- **边界情况**：
  - 输入集合为空，返回空集合。
  - 输入集合中只有一个元素，返回仅包含这个元素的集合。
  - 所有元素都是互质的，即没有任何元素是其他元素的因子，这时应返回仅包含最小元素的集合。

- **约束**：
  - 集合中元素数量的最大值为 1000，元素的值的范围也是1到1000。
  - 要考虑到时间复杂度和空间复杂度，以实现高效的算法。

## 3. 算法和策略
1. **排序**：首先对数组进行排序，这样可以保证我们在查找因子时，只需要向前查找即可。

2. **动态规划**：
   - 创建两个数组`dp`和`parent`，其中`dp[i]`表示在包括第`i`个元素的情况下，最大整除子集的大小，`parent[i]`用于记录`dp[i]`的最优解是由哪个前驱结点转移而来，以便最后我们可以通过回溯来构造这个子集。
   - 对于每个元素`nums[i]`，我们向前查找，尝试找到一个`j`（j < i），满足`nums[i] % nums[j] == 0`。如果找到，我们就检查`dp[j] + 1`是否大于`dp[i]`，如果是，就更新`dp[i]`和`parent[i]`。

3. **回溯构造解**：
   - 找到`dp`数组中的最大值及其索引`maxIndex`，这个最大值表示最大整除子集的大小，而索引用于回溯。
   - 从`maxIndex`开始，使用`parent`数组回溯至起点，过程中收集构成最大整除子集的元素。

4. **优化**：
   - 可以在动态规划过程中记录最大子集的大小和末尾元素的索引，以避免后续遍历`dp`数组找最大值。

---