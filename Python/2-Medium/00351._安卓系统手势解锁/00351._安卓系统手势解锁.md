[351. 安卓系统手势解锁](https://leetcode.cn/problems/android-unlock-patterns)

[ChatGPT](https://chat.openai.com/share/8a76812d-a245-498d-b22e-1796b8ed4c97)

---

## 1. 问题的内容
**1.1 题目描述**：
  安卓系统的手势解锁是通过连接屏幕上的9个点来完成的。如果手势的长度（即连接的点数）最小是`m`个点，最大是`n`个点（`1 <= m <= n <= 9`），请计算出所有可能的解锁图案的数量。需要注意的是，解锁图案中不能包括重复的点，且有些图案中的点可能因为被其他点阻挡而不能直接连接，只有当这些阻挡的点已经被连接时，才能连接两个被阻挡的点。

**1.2 示例**：
  - 如果`m = 1, n = 1`，那么结果应该是`9`，因为任意选择一个点都算是一种图案。
  - 如果`m = 1, n = 2`，结果应该是`65`（9个单点选择和56种有两个点的图案）。

**1.3 提示**:
  - 可以使用深度优先搜索（DFS）或者回溯法来解决这个问题，关键在于如何处理一个点到另一个点的过程中可能存在的“阻挡”问题。
  - 可以使用一个映射（如哈希表）来记录两个点之间是否存在直接连接的阻挡点。
  - 为了避免重复，需要记录已经访问过的点。

## 2. 边界情况和约束
- **边界情况**：
  - 最小点数`m`和最大点数`n`的界定：`1 <= m <= n <= 9`。
  - 每个解锁图案至少包含`m`个点，最多包含`n`个点。
  - 两个点之间的连接不能跨过未被连接的点，除非该点已经在当前路径中被访问过。

- **约束**：
  - 一个有效的解锁图案不能包含重复的点。
  - 必须处理点与点之间由于其他点阻挡而不能直接连接的情况。

## 3. 算法和策略
- **步骤1**：初始化数据结构
  - 使用一个`9x9`的二维数组（或哈希表）来记录两点间的阻挡点，如果没有阻挡点则记录为`None`或者特定值。
  - 使用一个数组或集合来记录已经访问过的点。

- **步骤2**：深度优先搜索（DFS）
  - 从每个点作为起点开始搜索，递归地尝试所有可能的下一个点。
  - 检查是否满足连接条件：如果两点之间有阻挡点，则该阻挡点必须已经被访问过。
  - 记录路径，每当路径长度达到`m`时，开始统计有效图案数，直到路径长度为`n`。

- **步骤3**：处理边界情况和约束
  - 确保不重复访问同一个点。
  - 处理两点间的直接连接问题，确保阻挡点被正确处理。

- **步骤4**：统计并返回结果
  - 对于每个起点，通过DFS找到所有有效的解锁图案，并统计数量。
  - 将每次DFS的结果累加，最终得到的总数即为所求的解锁图案的总数。

---