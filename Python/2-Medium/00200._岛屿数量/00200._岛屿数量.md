[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands)

[ChatGPT](https://chat.openai.com/share/147ec367-57fa-4010-957a-dc88eb4d164f)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode的[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands)问题要求计算在给定的二维地图中，陆地区域（用'1'表示）组成的岛屿数量。这里，我们假定地图的四周全是水，并且岛屿是通过相邻的陆地区域（水平或垂直）连接成的。

**1.2 示例**：
给定下面的2D地图：

```
11110
11010
11000
00000
```

岛屿的数量是 1。

**1.3 提示**:
- 可以使用深度优先搜索（DFS）、广度优先搜索（BFS）或并查集（Union Find）来解决此问题。
- 需要遍历二维数组，每找到一个'1'，就通过DFS或BFS将与之相连的所有'1'都标记为已访问，以防止重复计算。

## 2. 边界情况和约束
#### 边界情况：
- 地图为空或尺寸为0。
- 地图中只有水（'0'）没有陆地（'1'）。
- 地图中只有陆地没有水。

#### 约束：
- 地图是一个二维数组，其中只包含'1'（陆地）和'0'（水）。
- 地图的四周被认为全是水。

## 3. 算法和策略
1. **初始化计数器**：岛屿数量设为0。
2. **遍历地图**：对二维数组进行双层循环遍历，外层循环遍历行，内层循环遍历列。
3. **发现未访问过的陆地**：当遇到一个值为'1'的单元格时，增加岛屿计数器的值，并且使用DFS或BFS从这个单元格开始，遍历所有相连的陆地单元格，将它们标记为已访问。
4. **深度优先搜索（DFS）**：
   - 从当前单元格开始，探索四个方向（上、下、左、右）的相邻单元格。
   - 如果相邻单元格是陆地（'1'）且未被访问过，则递归地在该单元格上执行DFS，直到没有更多相连的陆地单元格可以被访问。
5. **广度优先搜索（BFS）**：
   - 从当前单元格开始，使用队列存储待访问的陆地单元格。
   - 将当前单元格加入队列，然后逐个取出队列中的单元格，探索其四个方向的相邻单元格。
   - 对于每个相邻的陆地单元格，如果未被访问，则将其加入队列，并标记为已访问。
6. **并查集（Union Find）**：
   - 为每个单元格初始化一个并查集。
   - 遍历地图，对于每个陆地单元格，尝试将其与四周的陆地单元格合并到同一个集合中。
   - 最终，岛屿的数量即为并查集中不同集合的数量。

---