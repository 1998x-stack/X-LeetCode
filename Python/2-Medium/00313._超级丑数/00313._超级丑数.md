[313. 超级丑数](https://leetcode.cn/problems/super-ugly-number)

[ChatGPT](https://chat.openai.com/share/aa5cbba1-63f1-4676-bd09-e4513d0eacfd)

---

## 1. 问题的内容
**1.1 题目描述**：
- LeetCode 313题「超级丑数」的问题要求我们找出第`n`个超级丑数。超级丑数是一个正整数，并且其所有质因数都出现在给定的质数列表`primes`中。例如，给定`primes = [2, 7, 13, 19]`，则序列的前几个超级丑数是`1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32...`，这里`1`通常被视为超级丑数。

**1.2 示例**：
- 输入：`n = 12, primes = [2,7,13,19]`
- 输出：`32`
- 解释：`[1,2,4,7,8,13,14,16,19,26,28,32]`是由给定质数`2, 7, 13, 19`生成的序列中的前12个数。

**1.3 提示**:
- `1 <= n <= 10^6`
- `1 <= primes.length <= 100`
- `2 <= primes[i] <= 1000`
- `primes[i]`互不相同。
- 结果在`32-bit`有符号整数范围内。

## 2. 边界情况和约束
- `n`的最小值为1，这意味着我们需要能够处理仅请求第一个超级丑数的情况，即输出为1。
- `primes`数组的长度至少为1，最多为100，需要确保算法在质数列表较大时依然高效。
- 质数列表中的每个数都在2到1000之间，且各不相同，这意味着不需要考虑重复因素的处理。
- 输出结果需要在32位有符号整数范围内，确保计算过程中不会出现整数溢出。

## 3. 算法和策略
为了解决这个问题，我们可以采用一个动态规划的方法，结合最小堆来高效找到第`n`个超级丑数。算法的基本思路如下：

1. **初始化**：
   - 创建一个列表`ugly`用于存储已经找到的超级丑数，初始时仅包含`1`。
   - 使用一个最小堆`heap`来保证每次都能从中取出当前未使用的最小超级丑数的候选。
   - 对于每个质数，我们需要跟踪它与`ugly`列表中元素的乘积，初始时，每个质数都与`ugly`列表中的第一个元素（即1）相乘。

2. **生成超级丑数**：
   - 使用一个循环来生成超级丑数，直到找到第`n`个为止。
   - 在每次循环中，从堆中取出最小元素，这个最小元素就是下一个超级丑数。
   - 将这个最小元素加入到`ugly`列表中。
   - 对于每个质数，计算它与最新添加的超级丑数的乘积，并将这些乘积添加到堆中。为了避免重复，如果某个乘积已经在堆中，可以选择跳过添加。
   - 注意：为了保证算法的效率，每次从堆中取出元素后，应当只计算与最新超级丑数相关的乘积，而不是重新计算所有质数的乘积。

3. **处理重复和边界情况**：
   - 使用一个集合来记录已经添加到堆中的乘积，避免重复添加相同的数。
   - 在整个过程中，确保不会超出`n`的限制以及32位整数的范围。

---

