[138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer)

[ChatGPT](https://chat.openai.com/share/e7f9bb2d-8036-4424-b1fa-0675323dd71b)

---

## 1. 问题的内容
**1.1 题目描述**：
- LeetCode 138 题，随机链表的复制，要求复制一个含有随机指针的链表。链表中的每个节点包含两个指针，一个指向链表中的下一个节点，另一个是随机指针，可能指向链表中的任意节点或者是 `null`。

**1.2 示例**：
- 输入：`head = [[7,null],[13,0],[11,4],[10,2],[1,0]]`
- 输出：`[[7,null],[13,0],[11,4],[10,2],[1,0]]`
- 解释：我们有一个链表，其头部节点的值为 7。节点值为 7 的下一个节点是值为 13 的节点，其随机指针指向头部节点；节点值为 13 的下一个节点是值为 11 的节点，其随机指针指向值为 1 的节点，以此类推。

**1.3 提示**:
- 链表是深拷贝。
- 你必须返回给定头部为 `head` 的链表的深拷贝。
- 链表节点数范围是 `[0, 1000]`。
- `-10000 <= Node.val <= 10000`
- 节点的随机指针可能指向链表中的任何节点或者是 `null`。

## 2. 边界情况和约束
**边界情况**：
- 链表为空，即 `head == null`。
- 链表只有一个节点，即 `head.next == null`。
- 链表节点的随机指针全为 `null`。

**约束**：
- 节点数范围 `[0, 1000]`，确保算法能处理大量节点。
- 节点值范围 `[-10000, 10000]`，验证算法的鲁棒性。

## 3. 算法和策略
**算法步骤**：
1. **创建映射**：遍历原始链表，为每个节点创建对应的新节点，并使用哈希表建立新旧节点之间的映射关系。
2. **复制指针**：再次遍历原始链表，通过哈希表找到每个旧节点对应的新节点，并设置新节点的 `next` 和 `random` 指针。
3. **返回新链表的头节点**。

**策略详解**：
- **第一遍遍历**：创建一个哈希表，键是原链表的节点，值是新链表的对应节点。遍历原链表，对于每个节点，生成一个新的节点，新节点的值与原节点相同，然后将原节点和新节点对应地存储在哈希表中。
- **第二遍遍历**：遍历原链表，使用哈希表找到每个节点对应的新节点，并设置新节点的 `next` 和 `random` 指针。`next` 指针可以通过当前旧节点的 `next` 指针在哈希表中找到对应的新节点。`random` 指针也是通过旧节点的 `random` 指针在哈希表中查找对应的新节点来设置。

---