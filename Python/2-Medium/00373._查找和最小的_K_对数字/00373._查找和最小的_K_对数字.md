[373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums)

[ChatGPT](https://chat.openai.com/share/223e10db-00cc-4456-863d-0feca3b791b1)

---

## 1. 问题的内容
**1.1 题目描述**：
- 题目来源：LeetCode 373. 查找和最小的K对数字
- 题目描述：给定两个以**升序排列**的整数数组`nums1`和`nums2`，以及一个整数`k`，定义一对值`(u,v)`，其中第一个元素来自`nums1`，第二个元素来自`nums2`。请找到和最小的`k`对数字`(u1,v1),(u2,v2) ...(uk,vk)`。

**1.2 示例**：
- 输入：`nums1 = [1,7,11]`, `nums2 = [2,4,6]`, `k = 3`
- 输出：`[(1,2),(1,4),(1,6)]`
- 解释：这些对的和最小，分别为`3, 5, 7`，没有其他组合的和小于`7`。

**1.3 提示**:
- 数组`nums1`和`nums2`的长度不大于`10^4`。
- 数组中的所有元素范围在`[-10^9, 10^9]`之间。
- `k`的值不超过`nums1`和`nums2`的长度之和。
- `nums1`和`nums2`都是升序排列的。

## 2. 边界情况和约束
#### **边界情况**：

1. **空数组**：如果`nums1`或`nums2`是空数组，那么结果显然也应该是空的，因为没有数字可以配对。
2. **`k`值大于可能的配对数量**：如果`k`的值大于`nums1.length * nums2.length`，即所有可能的配对数量，那么我们只能返回所有可能的配对而不是`k`对。
3. **数组长度不均**：`nums1`和`nums2`的长度可能不同，我们的算法设计需要能够灵活处理不同长度的数组。
4. **重复元素**：由于题目没有明确禁止数组中出现重复元素，我们的解决方案应能正确处理包含重复元素的数组。

#### **约束条件**：

1. **有序数组**：给定的两个数组是升序排列的，这是一个重要的条件，可以利用这一点来优化我们的算法。
2. **元素范围**：数组中的元素可以是从`-10^9`到`10^9`的任意整数，这意味着我们的解决方案必须能够处理非常大或非常小的整数。
3. **性能要求**：鉴于`nums1`和`nums2`的长度可能达到`10^4`，我们需要一个时间复杂度合理的算法来避免超时错误。

## 3. 算法和策略
#### 算法概述：

1. **使用优先队列（最小堆）**：利用优先队列来维护和最小的k对数字。优先队列能够保证每次我们都能快速获取当前和最小的一对数字。
2. **初始化堆**：将`nums1`中的每个元素与`nums2`中的第一个元素组成的对加入优先队列（假设为最小堆），并记录每对中`nums2`的索引。
3. **弹出和最小的对**：从优先队列中弹出和最小的一对数字，然后将这对数字中`nums1`的元素与`nums2`中的下一个元素（即当前对中`nums2`的元素的下一个）组成的新对加入到优先队列中。
4. **重复上述过程**，直到找到`k`对和最小的数字。

#### 算法详细步骤：

1. **检查边界条件**：如果`nums1`或`nums2`为空，或者`k`为0，则直接返回空列表。
2. **初始化优先队列**：创建一个优先队列（Python中的`heapq`），基于每对数字的和进行排序。
3. **填充堆**：将`nums1`中的每个元素与`nums2[0]`组成的对，以及对应的`nums2`的索引（初始为0），加入到优先队列中。
4. **循环提取和最小的对**：
   - 当优先队列非空且已提取对数小于`k`时，执行循环。
   - 从优先队列中弹出和最小的对，将这对数字添加到结果列表中。
   - 检查弹出的这对数字中，`nums2`的索引是否小于`nums2`的长度减一。如果是，将该对中`nums1`的元素与`nums2`中下一个元素组成的新对，以及新的索引加入到优先队列中。
5. **返回结果**：当循环结束或已找到`k`对数字时，返回结果列表。

#### 关键点和策略：

- **有效管理优先队列**：合理利用优先队列可以极大地提高算法的效率，尤其是在处理大数据量时。
- **边界条件处理**：适当处理空数组或特殊值的情况，保证算法的鲁棒性。
- **减少重复计算**：通过仅在必要时将新对加入到优先队列中，避免不必要的计算。

---