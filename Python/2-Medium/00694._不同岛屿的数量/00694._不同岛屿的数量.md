[694. 不同岛屿的数量](https://leetcode.cn/problems/number-of-distinct-islands)

[ChatGPT](https://chat.openai.com/share/26f6db18-bbd8-489c-85a7-eb446c28f5f8)

---

## 1. 问题的内容
**1.1 题目描述**：
题目要求找出一个二维网格中不同形状的岛屿数量。岛屿由上下左右相连的 `1` 组成，水域由 `0` 表示。岛屿的形状由它的相对位置定义，即使是相同的岛屿形状，如果位置或方向不同也被认为是不同的岛屿。

**输入**：
- `grid`：一个二维数组，其中包含 `0` 和 `1`，代表地图上的水域和岛屿。

**输出**：
- 一个整数，代表网格中不同岛屿的数量。

**1.2 示例**：
```
Input: grid = [
  [1,1,0,0,0],
  [1,1,0,0,0],
  [0,0,0,1,1],
  [0,0,0,1,1]
]
Output: 1
```
这个例子中，尽管有两个岛屿，但它们的形状和相对位置是一样的，所以只计为一个。

**1.3 提示**:
1. **标准化岛屿形状**：将每个岛屿的相对坐标转换成一个规范形式，例如按照字典序排序。
2. **生成唯一标识**：基于排序后的坐标生成一个唯一标识，可以是字符串或者其它形式。

## 2. 边界情况和约束
**边界情况**：
1. 网格为空或只有一行/一列。
2. 所有元素都是 `0` 或 `1`。
3. 岛屿形状特别复杂，例如，环绕、延伸到边界等。
4. 最大和最小尺寸的网格。

**约束**：
- 网格的大小：`1 <= m, n <= 50`。
- `grid[i][j]` 只包含 `0` 和 `1`。

## 3. 算法和策略
1. 遍历网格的每一个单元格。
2. 当发现一个 `1` 时，启动 DFS 来标记整个岛屿，并同时记录岛屿的形状。
3. 将岛屿形状存储为相对于起始点的方向序列（例如，向北为 'N', 向东为 'E', 向南为 'S', 向西为 'W'）。
4. 使用集合存储所有唯一的岛屿形状。
5. 完成遍历后，集合中的元素数量即为不同岛屿的数量。

---