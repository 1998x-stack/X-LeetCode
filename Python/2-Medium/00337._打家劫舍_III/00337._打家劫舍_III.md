[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii)

[ChatGPT](https://chat.openai.com/share/3b58beb0-31fb-4e03-a08a-0b9cfbd09706)

---

## 1. 问题的内容
**1.1 题目描述**：
在《打家劫舍 III》这个问题中，你面对的是一个在树形结构社区进行盗窃的场景。每个房屋在树的节点上，你不能偷窃任何相邻的房屋（两个直接相连的节点被认为是相邻的），任务是计算不触动警报的情况下能够偷窃到的最大金额。

**1.2 示例**：
给定一个树形结构，例如：

```
     3
    / \
   2   3
    \   \
     3   1
```

最大的盗窃金额为 `3 + 3 + 1 = 7`。

再如：

```
     3
    / \
   4   5
  / \   \
 1   3   1
```

最大的盗窃金额为 `4 + 5 = 9`。

**1.3 提示**:
- 树的节点数的范围是 `[1, 10^4]`。
- 每个节点的值都是一个正整数。

## 2. 边界情况和约束
### 边界情况
- **空树**：当树为空时，最大盗窃金额为0。
- **单节点树**：只有一个节点时，最大盗窃金额即该节点的值。
- **所有节点都只有一个子节点**：这种线性结构下，问题退化成了普通的打家劫舍问题。

### 约束
- 树的节点数最多为 `10^4`，需要注意算法的时间复杂度，以避免超时。
- 节点的值为正整数，需要考虑计算过程中的溢出问题。

## 3. 算法和策略
### 算法设计
采用**深度优先搜索（DFS）**的方式遍历树，并且利用动态规划（DP）的思想解决问题。对于每个节点，考虑两种情况：

1. **偷当前节点**：此时不能偷取其直接的子节点，但可以偷取子节点的子节点。
2. **不偷当前节点**：此时可以偷取其直接的子节点。

定义一个辅助函数 `rob(node)`，返回一个长度为2的数组，其中 `arr[0]` 表示不偷当前节点时的最大金额，`arr[1]` 表示偷当前节点时的最大金额。

### 策略
- 对于每个节点，使用DFS遍历其子节点。
- 对每个子节点调用 `rob(node)`，获取偷或不偷子节点的最大金额。
- 利用子节点返回的结果，更新当前节点的最大金额。
  - 不偷当前节点的最大金额为所有子节点不偷和偷情况下金额的最大值之和。
  - 偷当前节点的最大金额为当前节点的值加上所有子节点不偷时的金额之和。
- 返回当前节点的结果。

---