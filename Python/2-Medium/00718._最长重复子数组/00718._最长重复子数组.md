[718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray)

[ChatGPT](https://chat.openai.com/share/4984743b-0cbc-4fd0-b6fb-d0f20e5dec07)

---

## 1. 问题的内容
**1.1 题目描述**：
题目要求找出两个整数数组（记作 `nums1` 和 `nums2`）中的最长重复子数组的长度。这个子数组在两个数组中都应该出现，并且具有相同的元素顺序。这个问题属于动态规划的范畴。

**1.2 示例**：
输入：`nums1 = [1,2,3,2,1]`, `nums2 = [3,2,1,4,7]`
输出：3
解释：最长的重复子数组是 `[3,2,1]`，长度为3。

**1.3 提示**:
- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 100`

## 2. 边界情况和约束
**边界情况**：
1. 两个数组中任意一个数组长度为0时，最长重复子数组的长度为0。
2. 数组中所有元素都相同，且长度相等。
3. 数组完全没有重复元素。

**约束**：
- 数组长度最多为1000，数组元素大小在0到100之间。

## 3. 算法和策略
**动态规划算法设计**：
使用一个二维数组 `dp` 记录状态，其中 `dp[i][j]` 表示 `nums1` 中以第 `i` 个元素结尾和 `nums2` 中以第 `j` 个元素结尾的最长重复子数组的长度。
- 如果 `nums1[i] == nums2[j]`，则 `dp[i][j] = dp[i-1][j-1] + 1`；
- 如果 `nums1[i] != nums2[j]`，则 `dp[i][j] = 0`。

算法的时间复杂度为 `O(m*n)`，其中 `m` 和 `n` 分别是两个数组的长度。

---

