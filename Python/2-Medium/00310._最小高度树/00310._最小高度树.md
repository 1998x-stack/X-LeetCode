[310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees)

[ChatGPT](https://chat.openai.com/share/86481cf4-0c4c-4ffa-8652-17f9824419d4)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode问题310《最小高度树》要求我们找到所有最小高度树的根节点，给定的是一个无向图，表示为一个n个节点的树，以及其边。我们的目标是找到一个或多个根节点，使得树的高度最小。
- **输入**：节点的数量`n`和一个二维数组`edges`，表示节点间的边。
- **输出**：所有可能的最小高度树的根节点列表。

**1.2 示例**：
假设有`n = 4`个节点，边`edges = [[1, 0], [1, 2], [1, 3]]`。可视化这棵树后，我们可以发现根节点为1时树的高度最小，因此输出为`[1]`。

**1.3 提示**:
- 树是一个无环连通图。
- 最小高度树可能不只一个。
- 试图从叶子节点向中心靠拢的思想来解决问题。

## 2. 边界情况和约束
### 边界情况
- **节点数量**：`n == 1`时，即树只有一个节点，这个节点本身就是最小高度树的根。
- **线性树**：所有节点形成一条直线时，最小高度树的根会有两个（除非树只有两个节点，这种情况下只有一个根）。
- **完全平衡树**：当树完全平衡时，根节点唯一，并且是树的中心。

### 约束
- `1 <= n <= 2 * 10^4`，确保算法在大规模数据下仍然高效。
- 边的描述`edges[i] = [ui, vi]`保证`ui < vi`，即边的描述是有序的。

## 3. 算法和策略
### 算法步骤
1. **初始化**：创建一个图（使用邻接表表示）和一个度的数组来记录每个节点的度（即连接的边数）。
2. **找到所有叶子节点**：遍历度数组，找到所有度为1的节点，这些节点是叶子节点。
3. **逐层剥离**：将叶子节点从图中删除，同时更新相邻节点的度。每次删除后，新的叶子节点会出现，重复这个过程。
4. **终止条件**：当剩下的节点数小于等于2时停止，此时的节点即为所求的根节点。

### 策略细节
- 使用**队列**存储当前层的叶子节点，方便逐层处理。
- 为了有效地删除节点和更新度，需要维护一个好的数据结构来存储图和度。
- 在删除节点时，同时删除其对应的边，这需要在邻接表和度数组中进行操作。

---