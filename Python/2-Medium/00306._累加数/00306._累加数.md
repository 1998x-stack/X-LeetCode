[306. 累加数](https://leetcode.cn/problems/additive-number)

[ChatGPT](https://chat.openai.com/share/1d132434-f46c-4a5b-b2b0-beb723e42344)

---

## 1. 问题的内容
**1.1 题目描述**：
**累加数**是一个字符串，定义为至少包含三个数字的字符串，除了最开始的两个数外，字符串中的其他数都是前两个数之和。例如，给定的字符串"112358"是一个累加数，因为 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8。累加数中的数字**不应该**以零开头，除非这个数本身就是0。因此，"0123"不是一个累加数，因为 1 + 2 = 3，但是02不是一个有效的表示。

- **问题核心**：给定一个字符串，判断它是否为累加数。
- **输入**：字符串`num`
- **输出**：如果`num`是一个累加数，则返回`True`；否则，返回`False`。

**1.2 示例**：
- **输入**：`num = "112358"`
- **输出**：`True`
  解释：序列为：1, 1, 2, 3, 5, 8。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

- **输入**：`num = "199100199"`
- **输出**：`True`
  解释：序列为：1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199

**1.3 提示**:
1. `0 <= num.length <= 35`
2. `num` 仅由数字组成

## 2. 边界情况和约束
### 边界情况

1. 字符串长度为0或1时，显然不可能形成累加数，应直接返回`False`。
2. 字符串以"0"开头的情况，需要特别处理，因为累加数可以是"0"本身，但是不能有前导零（除非数本身是0）。

### 约束

1. **长度约束**：由于字符串最长为35，这意味着我们的算法复杂度至少应该保持在合理的多项式时间复杂度内，以保证能在实际运行中得到结果。
2. **数值范围**：字符串代表的数字可能会超过常规整数类型的范围，需要考虑使用高精度数值处理。

## 3. 算法和策略
### 算法步骤

1. **遍历第一个数的所有可能**：第一个数可以是开头的任何一段，但需要注意，如果第一个数选择了以'0'开头的数字，则这个数只能是'0'。
2. **遍历第二个数的所有可能**：在确定了第一个数之后，第二个数可以是第一个数之后的任何一段，同样地，如果以'0'开头，则这个数只能是'0'。
3. **验证剩余部分**：在确定了前两个数之后，尝试用它们的和去匹配剩余字符串的开头部分，如果匹配成功，则递归地继续这一过程，直到字符串被完全匹配。
4. **回溯**：如果在任何时候发现当前选择的数无法满足累加数的规则，则回溯，尝试其他可能的数。

### 策略说明

- **使用字符串操作**：由于数字可能非常大，我们可以直接使用字符串来处理数字的加法，避免数值溢出的问题。
- **剪枝**：如果在任何步骤中，剩余字符串的长度小于当前的两个数中最大的长度，那么可以提前结束尝试，因为不可能再形成有效的累加数序列。

---