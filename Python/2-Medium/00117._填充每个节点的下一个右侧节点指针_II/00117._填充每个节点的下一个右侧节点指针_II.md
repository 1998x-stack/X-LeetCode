[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii)

[ChatGPT](https://chat.openai.com/share/7ea63ce5-113a-421f-a4a9-d45de7656ee8)

---

## 1. 问题的内容
**1.1 题目描述**：
题目来源于 LeetCode，编号为 117，题目名称为“填充每个节点的下一个右侧节点指针 II”。这个问题要求我们给定一个二叉树，我们需要将它的每个节点的 next 指针指向其右侧的节点。如果找不到右侧的节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。重要的是，给定的二叉树可能是一个完美二叉树也可能不是，即它不保证每个层级的节点数都是满的。

**1.2 示例**：
给定二叉树：

```
     1
   /  \
  2    3
 / \    \
4   5    7
```

经过连接后，我们希望得到的结果是：

```
     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \    \
4-> 5 -> 7 -> NULL
```

**1.3 提示**:
- 树中节点的数量少于 6000
- -100 <= node.val <= 100

## 2. 边界情况和约束
1. **空树的情况**：
   - 如果给定的二叉树为空，我们需要确保算法能够正确处理，即不进行任何操作，直接返回。

2. **只有一个节点的树**：
   - 对于只有根节点而没有子节点的树，需要确保根节点的 next 指针保持为 NULL，因为没有右侧节点。

3. **所有叶子节点**：
   - 所有叶子节点的 next 指针应该指向 NULL，因为它们是各自层级的最后一个节点。

4. **不完美二叉树的层**：
   - 对于每个层级，特别是不完美二叉树中的层级，算法需要能够跳过 NULL 节点，正确地将非空节点连接起来。

5. **节点值的范围**：
   - 节点值的范围在 -100 到 100 之间。这意味着节点值不会影响连接过程，但是我们需要注意处理这个值域范围内的数据。

6. **节点数量的限制**：
   - 树中节点的数量少于 6000。这个约束条件意味着我们需要考虑解决方案的空间和时间复杂度，以确保算法能够在合理的时间内完成。

## 3. 算法和策略
### 算法策略：

我们采用层次遍历的方法，但因为树可能不完美，我们需要一个办法来连接跨越空子节点的右侧节点。算法可以分为以下几个步骤：

1. **使用辅助节点（哨兵节点）**：
   - 对于树的每一层，使用一个哨兵节点（dummy node）作为该层的起始点。这样可以帮助我们处理层中第一个节点的连接问题。

2. **层次遍历**：
   - 通过维护一个指向当前层第一个节点的指针（使用哨兵节点开始），遍历当前层的所有节点。对于每个节点，我们尝试更新它的 next 指针指向同层的下一个节点。

3. **连接同层节点**：
   - 遍历当前层时，我们需要维护两个指针：一个用于遍历当前层（current pointer），另一个用于链接下一层的节点（next level pointer）。通过这种方式，我们可以在遍历当前层的同时建立下一层节点之间的连接。

4. **移动到下一层**：
   - 完成当前层的遍历和连接后，移动到下一层。我们可以通过哨兵节点的 next 指针找到下一层的第一个节点。

5. **重复直到所有层都被处理**。

### 关键点：

- **辅助节点（哨兵节点）**：用于简化对每层第一个节点的处理。
- **两个指针**：一个指针用于遍历当前层，另一个指针用于链接下一层的节点。
- **层次遍历**：通过层次遍历，我们可以确保每个节点都被访问，并且正确地连接到其右侧的节点。

---