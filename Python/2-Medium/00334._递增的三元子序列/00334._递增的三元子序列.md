[334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence)

[ChatGPT](https://chat.openai.com/share/dd5a5e34-f479-4dd6-b775-97cf279efc83)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个未排序的数组，判断这个数组中是否存在长度为3的递增子序列。

数学表达式如下: 如果存在这样的 i, j, k, 且满足 0 ≤ i < j < k < n，使得 arr[i] < arr[j] < arr[k]，返回 true ；否则返回 false 。

**1.2 示例**：
- 示例 1:
  输入: [1,2,3,4,5]
  输出: True
  解释: 任意三个数，比如 1, 2, 3 或 2, 3, 4，都构成递增的三元子序列。

- 示例 2:
  输入: [5,4,3,2,1]
  输出: False
  解释: 没有任何三个数能构成递增的三元子序列。

- 示例 3:
  输入: [2,1,5,0,4,6]
  输出: True
  解释: 子序列 [1, 4, 6] 或 [2, 5, 6] 都是递增的三元子序列。

**1.3 提示**:
- 函数需要返回一个布尔值，即是否存在递增的三元子序列。
- 数组的长度不会超过 10^5。
- 数组中的每个元素都是一个整数，范围在 [-2^31, 2^31 - 1]。

## 2. 边界情况和约束
### 边界情况

- 数组长度小于3时，无法构成三元组，直接返回False。
- 数组所有元素相同，也无法构成递增的三元组，返回False。
- 数组中元素处于整数的边界值，需要考虑整数溢出的问题。

### 约束

- 时间复杂度：希望在O(n)内解决问题，以适应大规模数据的需求。
- 空间复杂度：尽量使用O(1)的额外空间，减少内存使用。

## 3. 算法和策略
### 设计思路

1. **初始化两个变量**：`first` 和 `second`，分别用来存储遍历过程中遇到的最小值和次小值。
2. **遍历数组**：对于数组中的每个元素 `num`，进行以下判断：
   - 如果 `num` 小于或等于 `first`，更新 `first = num`。这表示我们找到了当前遍历过程中的最小值。
   - 否则，如果 `num` 小于或等于 `second`，更新 `second = num`。这表示我们找到了一个比之前记录的最小值大，但在当前遍历点是第二小的值。
   - 否则，如果找到一个比 `first` 和 `second` 都大的值，表示我们找到了一个递增的三元子序列，直接返回True。
3. **返回False**：如果遍历完成后没有返回True，说明没有找到递增的三元子序列，返回False。

### 算法策略

该策略的核心在于贪心地更新遍历过程中的最小值和次小值，不断地降低寻找第三个值的条件，直到找到一个比前两者都大的值。这个过程确保了算法的时间复杂度为O(n)，同时只使用了常数级别的额外空间，满足了问题的约束条件。

---