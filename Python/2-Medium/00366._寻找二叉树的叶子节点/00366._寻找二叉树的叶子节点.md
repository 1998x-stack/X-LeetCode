[366. 寻找二叉树的叶子节点](https://leetcode.cn/problems/find-leaves-of-binary-tree)

[ChatGPT](https://chat.openai.com/share/3a5a0897-2acf-4005-8acf-d0065d458097)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode 366题目要求开发一个算法，找出给定二叉树的所有叶子节点，并按照从根到叶的顺序，一层层地删除它们，直到树为空。这个过程中，每一层的叶子节点组成一个列表，所有列表组成一个列表作为最终结果返回。

**1.2 示例**：
LeetCode 366题目要求开发一个算法，找出给定二叉树的所有叶子节点，并按照从根到叶的顺序，一层层地删除它们，直到树为空。这个过程中，每一层的叶子节点组成一个列表，所有列表组成一个列表作为最终结果返回。

### 示例

假设有一个二叉树如下：

```
    1
   / \
  2   3
 / \     
4   5    
```

对于这个树，按题目要求的操作顺序，叶子节点的删除顺序是：

- 第一次删除叶子节点 `[4,5,3]`，树变为：

```
  1
 /   
2     
```

- 第二次删除叶子节点 `[2]`，树变为：

```
1
```

- 第三次删除叶子节点 `[1]`，树为空。

所以，按照题目要求的格式，输出应该是 `[[4,5,3], [2], [1]]`。

**1.3 提示**:
- 考虑使用深度优先搜索（DFS）策略，因为我们需要从底向上处理每个节点。
- 可以考虑记录每个节点的深度，从而将同一深度的叶子节点放在同一个列表中。

## 2. 边界情况和约束

- **空树**：如果给定的二叉树为空，即根节点为`None`，则直接返回空列表`[]`。
- **单节点树**：如果二叉树只有一个节点，那么结果就是`[[root.val]]`。
- **完全二叉树**：在完全二叉树中，每一层的叶子节点都会被一次性删除。
- **约束**：树中的节点数在 `[1, 100]` 范围内，节点值的绝对值不超过 `100`。

## 3. 算法和策略
1. **使用深度优先搜索（DFS）**：从根节点开始，递归地搜索每个节点的左右子树。
2. **记录深度**：在DFS过程中，计算每个节点的深度（叶子节点的深度为0，每向上一层深度加1）。
3. **按深度组织叶子节点**：创建一个列表（或字典），以节点的深度作为键，以该深度下的所有叶子节点的值组成的列表作为值。
4. **从底向上删除**：按照深度从小到大的顺序，逐层收集并删除叶子节点。

### 算法详细步骤

1. 定义一个辅助函数`dfs(node)`，用于深度优先搜索，返回节点的深度，并在搜索过程中收集叶子节点。
2. 在`dfs`函数内部，如果当前节点是叶子节点（即没有子节点），则将其值加入到对应深度的列表中，并返回其深度（为0）。
3. 如果当前节点不是叶子节点，递归地调用`dfs`函数处理左子树和右子树，计算左右子树的最大深度，并以此作为当前节点的深度（加1表示当前节点的深度）。
4. 将当前节点的值添加到其深度对应的列表中。
5. 在主函数中调用`dfs`函数，并根据收集到的叶子节点的深度列表构造最终结果。


---