[322. 零钱兑换](https://leetcode.cn/problems/coin-change)

[ChatGPT](https://chat.openai.com/share/5c59c559-0b81-488c-b400-03c73ca207b8)

---

## 1. 问题的内容
**1.1 题目描述**：
- **问题链接**：[322. 零钱兑换](https://leetcode.cn/problems/coin-change)
- **问题描述**：给定不同面额的硬币`coins`和一个总金额`amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回`-1`。你可以认为每种硬币的数量是无限的。

**1.2 示例**：
- **示例1**：
  - 输入：`coins = [1, 2, 5], amount = 11`
  - 输出：`3` 
  - 解释：11 = 5 + 5 + 1
- **示例2**：
  - 输入：`coins = [2], amount = 3`
  - 输出：`-1`

**1.3 提示**:
- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

## 2. 边界情况和约束
#### 边界情况
- **总金额为0**：当`amount = 0`时，不需要任何硬币，所需硬币数量为0。
- **硬币数组为空**：虽然题目没有直接提及，但如果`coins`数组为空，则无法凑成任何金额，应返回`-1`。
- **无法凑成总金额**：如果给定的硬币无法凑成总金额，返回`-1`。

#### 约束
- 硬币数量无限。
- 硬币数组长度最大为12，且每个元素的最大值为`2^31 - 1`。
- 总金额的最大值为`10^4`。

## 3. 算法和策略
#### 算法描述
使用**动态规划**解决此问题。定义一个数组`dp`，其中`dp[i]`代表凑成金额`i`所需的最少硬币数量。初始化`dp[0] = 0`，因为金额为0时不需要硬币，其余为一个很大的数，例如`amount + 1`，表示初始时无法凑成金额。

**转移方程**：对于每个金额`i`，遍历每个硬币`coin`，如果`coin <= i`，则`dp[i] = min(dp[i], dp[i - coin] + 1)`。这表示如果当前硬币的面额不超过当前金额`i`，则当前金额的最小硬币数可以从`i - coin`的金额加上这一个硬币中取最小值。

**初始化**：`dp[0] = 0`，其余位置初始化为`amount + 1`。

**目标**：计算出`dp[amount]`，如果`dp[amount]`为`amount + 1`，则表示无法凑成，返回`-1`，否则返回`dp[amount]`。

#### 策略
- **动态规划数组的初始化和定义**。
- **逐步填充动态规划数组**，根据转移方程更新`dp`数组。
- **处理结果**，根据`dp[amount]`的值返回结果。

---