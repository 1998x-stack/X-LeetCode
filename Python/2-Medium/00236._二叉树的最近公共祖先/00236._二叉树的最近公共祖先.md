[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)

[ChatGPT](https://chat.openai.com/share/95f4cbf5-6c6f-4bac-a88b-af65ab57b88a)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个二叉树，找到该树中两个指定节点的最近公共祖先（LCA）。一个节点也可以是它自己的祖先。

- **公共祖先的定义**：对于树中的两个节点 p 和 q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。

**1.2 示例**：
- **输入**：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
- **输出**：3
- **解释**：节点 5 和节点 1 的最近公共祖先是节点 3。

**1.3 提示**:
- 树中的节点数目在范围 [2, 10^5] 内。
- -10^9 <= Node.val <= 10^9
- 所有 Node.val 互不相同。
- p != q
- p 和 q 均存在于给定的二叉树中。

## 2. 边界情况和约束
### 边界情况

1. **树仅包含两个节点**：在这种情况下，一个节点是另一个节点的父节点，因此父节点就是最近的公共祖先。
2. **p 和 q 其中一个是根节点**：根节点自然成为最近的公共祖先。
3. **p 和 q 在树的同一侧**：需要遍历该侧的树来找到最近的公共祖先。
4. **p 和 q 在树的不同侧**：根节点是它们的最近公共祖先。
5. **树中存在大量节点时的性能考虑**：确保算法具有良好的时间复杂度，以处理大规模数据。

### 约束

1. **节点值的唯一性**：每个节点的值都是唯一的，我们可以利用这一点来标识和查找节点。
2. **节点数目范围**：节点数目在 [2, 10^5] 范围内，算法必须能高效处理大量节点。
3. **节点值范围**：节点值在 -10^9 至 10^9 之间，需要考虑到数值处理的准确性。
4. **p 和 q 的存在性**：p 和 q 保证存在于给定的二叉树中，这意味着我们不需要对不存在的节点进行特殊处理。

## 3. 算法和策略
### 算法设计

1. **递归搜索**：
   - 我们可以使用递归来遍历二叉树，搜索节点 p 和 q。
   - 对于每个遍历到的节点，我们检查它是否等于 p 或 q。
   - 如果一个节点正好是 p 或 q，我们将它标记为找到。

2. **返回条件**：
   - 如果当前节点为空或等于 p 或 q，则返回当前节点。
   - 这意味着我们找到了 p、q 中的一个或到达了叶子节点。

3. **递归左右子树**：
   - 对当前节点的左子树进行递归调用，得到左侧的结果。
   - 对当前节点的右子树进行递归调用，得到右侧的结果。

4. **后序遍历逻辑**：
   - 如果左右子树递归调用都返回非空结果，意味着当前节点是 p 和 q 的最近公共祖先。
   - 如果只有一侧返回非空结果，意味着 p 和 q 都位于这一侧，将这一侧的结果向上返回。
   - 如果两侧都返回空，意味着当前子树中没有 p 和 q，返回空。

### 策略细节

- **使用后序遍历**：这种方式先处理子节点，再处理父节点，有助于从底向上找到最近公共祖先。
- **减少不必要的遍历**：一旦找到 p 或 q，就无需进一步遍历其他分支。
- **利用递归返回值**：通过返回值传递找到的节点信息，避免使用额外的数据结构。

---