[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs)

[ChatGPT](https://chat.openai.com/share/88a9dd8b-fb67-4902-bc31-ec3e908914d)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯地改变节点内部的值，而是需要实际的进行节点交换。

**1.2 示例**：
输入：head = [1,2,3,4]
输出：[2,1,4,3]

**1.3 提示**:
- 链表中节点的数目在范围 [0, 100] 内
- 0 <= Node.val <= 100

## 2. 边界情况和约束
- **边界情况**：
  - 链表为空时，返回空链表。
  - 链表只有一个节点时，返回原链表，因为没有相邻节点可以交换。

- **约束条件**：
  - 链表节点数目的范围是 [0, 100]。
  - 节点的值的范围是 [0, 100]。


## 3. 算法和策略
1. 创建一个哑节点（dummy node）作为新链表的头部，其 next 指向原链表的头节点，这有助于处理头节点交换的边界情况。
2. 使用三个指针：`prev`（指向当前处理对的前一个节点），`current`（当前处理的第一个节点），`next`（当前处理的第二个节点）。
3. 在链表上迭代，每次处理一对节点。将 `prev` 的 `next` 指向 `next`，`current` 的 `next` 指向 `next` 的 `next`，最后 `next` 的 `next` 指向 `current`，以完成交换。
4. 更新 `prev` 指针到当前处理对的后一个节点，为下一对交换做准备。
5. 当链表中没有更多节点可以处理时，迭代结束。
6. 返回哑节点的 `next`，作为新链表的头部。
---

