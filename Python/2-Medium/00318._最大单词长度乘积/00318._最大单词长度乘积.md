[318. 最大单词长度乘积](https://leetcode.cn/problems/maximum-product-of-word-lengths)

[ChatGPT](https://chat.openai.com/share/4ac730fe-ab9a-420a-a60f-3054acbbe748)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode题目[318. 最大单词长度乘积](https://leetcode.cn/problems/maximum-product-of-word-lengths)要求我们找到一个字符串数组中两个单词的最大长度乘积，条件是这两个单词不包含相同的字符。可以假设每个单词只包含英文字母的小写形式。

**1.2 示例**：
- **示例1**:
    - 输入: `["abcw","baz","foo","bar","xtfn","abcdef"]`
    - 输出: `16`
    - 解释: 这两个单词可以是 "abcw", "xtfn"。
- **示例2**:
    - 输入: `["a","ab","abc","d","cd","bcd","abcd"]`
    - 输出: `4`
    - 解释: 这两个单词可以是 "ab", "cd"。
- **示例3**:
    - 输入: `["a","aa","aaa","aaaa"]`
    - 输出: `0`
    - 解释: 没有符合条件的两个单词。

**1.3 提示**:
- `1 <= words.length <= 10^3`
- `0 <= words[i].length <= 10^3`
- `words[i]`仅包含小写字母

## 2. 边界情况和约束
- **边界情况**:
    1. 单词数组长度为1时，没有第二个单词可用来形成乘积，应返回0。
    2. 单词长度为0时，应被忽略，因为它们不会对最大长度乘积产生贡献。
    3. 单词中含有重复字符不影响程序逻辑，因为题目要求是两个单词**不包含相同的字符**，而不是单词内部不能有重复字符。

- **约束**:
    1. 输入单词只包含小写英文字母。
    2. 需要处理的单词数量可能达到1000个，单词长度可达1000，算法需要高效以避免超时。

## 3. 算法和策略
### 算法设计

1. **初始化**:
    - 创建一个哈希表，键是单词对应的二进制数，值是该单词的长度。这里二进制数的每一位代表一个字母是否在单词中出现（26位，分别对应26个英文字母）。

2. **转换单词为二进制表示**:
    - 遍历每个单词，对于单词中的每个字符，计算它在字母表中的偏移量`offset`（即`char - 'a'`），然后将`1`左移`offset`位，与当前单词的二进制表示做或操作。

3. **计算最大长度乘积**:
    - 双重循环遍历哈希表中所有单词的二进制表示，如果两个单词的二进制表示做与操作结果为0，说明它们没有公共字母，此时计算这两个单词长度的乘积，并更新最大乘积结果。

4. **返回结果**:
    - 返回最大长度乘积。

### 策略讨论

- **位运算的优势**: 使用位运算可以快速检测两个单词是否有重复的字符，大大提高算法效率。
- **空间与时间权衡**: 通过使用哈希表存储单词的二进制表示和长度，我们牺牲了一些空间来换取时间效率。

---