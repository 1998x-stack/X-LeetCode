[40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii)

[ChatGPT](https://chat.openai.com/share/d54de183-418f-4a1b-b77f-2e0f40d882c)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个候选人编号的集合 `candidates` 和一个目标数 `target`，找出 `candidates` 中所有可以使数字和为 `target` 的组合。`candidates` 中的每个数字在每个组合中只能使用 **一次**。

**1.2 示例**：

假设我们有以下输入：

- `candidates = [10,1,2,7,6,1,5]`
- `target = 8`

输出应该是：

```plaintext
[
  [1, 1, 6],
  [1, 2, 5],
  [1, 7],
  [2, 6]
]
```

这个示例展示了如何从数组 `candidates` 中选择数字，使得它们的和等于目标值 `8`。注意，数组中有重复的数字（例如 `1`），但是每个组合需要是唯一的。

**解释**：
- 组合 `[1, 1, 6]` 使用了数组中的两个 `1` 和一个 `6`。
- 组合 `[1, 2, 5]` 使用了一个 `1`、一个 `2` 和一个 `5`。
- 组合 `[1, 7]` 使用了一个 `1` 和一个 `7`。
- 组合 `[2, 6]` 使用了一个 `2` 和一个 `6`。

所有这些组合的和都是 `8`，并且没有重复的组合。

**1.3 提示**:
- 解集不能包含重复的组合。
1. **使用回溯法**：组合总和问题适合使用回溯法求解，因为需要探索所有可能的组合方式，直到找到所有满足条件的解。
2. **排序**：先对数组进行排序可以帮助我们在回溯时更容易地剪枝，同时也便于处理重复元素。
3. **剪枝**：在递归的过程中，如果当前组合的和已经大于目标值 `target`，则可以停止进一步的递归，以避免不必要的计算。
4. **处理重复组合**：由于数组中可能包含重复数字，需要特别注意如何避免生成重复的组合。一种方法是在同一层的递归中，如果发现当前数字与之前的数字相同，则跳过当前数字。

## 2. 边界情况和约束


#### 2.1 确定输入数组的大小范围
- 输入数组 `candidates` 的大小可能从空数组到包含多个元素的数组不等。因此，算法需要能够处理从零到任意数量元素的情况。

#### 2.2 确定目标值的范围
- 目标值 `target` 可以是任何整数。算法需要能处理从负数、零到正数的目标值。

#### 2.3 分析数组中元素的范围
- 数组中的元素可以是正数、负数或零。尽管在大多数组合总和问题中，元素通常是正数，了解算法是否也能处理非正数是有意义的。

#### 2.4 考虑重复元素的处理
- 数组中可能包含重复元素。算法设计时必须考虑如何避免在结果集中出现重复的组合。

## 3. 算法和策略

#### 3.1 选择合适的数据结构
- 使用列表 (list) 存储当前的组合 (combination)。
- 使用列表存储最终结果 (all_combinations)。

#### 3.2 设计递归或回溯算法的框架
- 定义一个回溯函数 `backtrack(start, current_combination, current_sum)`，其中 `start` 是当前选择范围的起始索引，`current_combination` 是当前组合，`current_sum` 是当前组合的总和。
- 从 `start` 到数组末尾迭代，尝试将每个元素加入到 `current_combination`。
- 如果 `current_sum + candidates[i] > target`，则跳过当前元素（剪枝）。
- 如果 `current_sum + candidates[i] == target`，则将 `current_combination` 添加到最终结果中。
- 递归调用 `backtrack(i + 1, current_combination + [candidates[i]], current_sum + candidates[i])`，注意 `i + 1` 作为下一次递归的起始索引，以避免重复使用同一个元素。

#### 3.3 确定剪枝条件以提高效率
- 在递归之前，如果当前元素与前一个元素相同，则跳过当前元素，避免产生重复组合。
- 当 `current_sum` 超过 `target` 时立即返回，避免无意义的递归调用。

#### 3.4 设计算法以处理重复组合的问题
- 对输入数组 `candidates` 进行排序，以方便剪枝和避免重复。
- 在每一层的迭代中，只选择第一次出现的元素进行递归调用，如果当前元素与前一个元素相同，则跳过以避免重复。


---

