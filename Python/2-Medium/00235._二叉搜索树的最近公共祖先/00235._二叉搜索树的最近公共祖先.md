[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree)

[ChatGPT](https://chat.openai.com/share/d0203a3f-67d8-48a1-acc1-a75ac5cc1fab)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先（LCA）。对于二叉树，我们在节点 p 和 q 的祖先中找到最低的节点（我们允许一个节点为自己的祖先），这意味着该节点既可以在 p 的祖先路径上，也可以在 q 的祖先路径上。

二叉搜索树（BST）的定义：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。左右子树也必须是二叉搜索树。

**1.2 示例**：
给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

```
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5
```

- **示例1**: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
  - 输出: 6
  - 解释: 节点 2 和节点 8 的最近公共祖先是 6。
- **示例2**: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
  - 输出: 2
  - 解释: 节点 2 和节点 4 的最近公共祖先是 2，因为根据定义最近公共祖先节点可以为节点本身。

**1.3 提示**:
- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

## 2. 边界情况和约束
1. **树为空**：若二叉搜索树为空，即没有节点，则不存在公共祖先。
2. **p 或 q 为根节点**：如果 p 或 q 其中一个节点是根节点，那么最近公共祖先为根节点本身，因为根节点没有父节点。
3. **p 和 q 分别位于根节点的两侧**：这意味着根节点是 p 和 q 的最近公共祖先，因为在二叉搜索树中，左子树的所有值都小于根节点，右子树的所有值都大于根节点。
4. **p 和 q 都位于根节点的同一侧**：若 p 和 q 都在根节点的左侧或右侧，我们需要在相应的子树中继续寻找最近公共祖先。
5. **一个节点是另一个节点的祖先**：在这种情况下，较高层次的节点（即祖先节点）是最近公共祖先。
6. **节点值的唯一性和存在性**：根据提示，所有节点的值都是唯一的，且 p、q 为不同节点且均存在于给定的二叉搜索树中。这简化了问题，因为我们不需要考虑重复值或不存在节点的情况。

## 3. 算法和策略
### 算法思路

1. **从根节点开始遍历**：
   - 将当前节点初始化为根节点。

2. **比较当前节点与 p 和 q 的值**：
   - 如果当前节点的值大于 p 和 q 的值，说明 p 和 q 都在当前节点的左子树中，因此向左子树移动。
   - 如果当前节点的值小于 p 和 q 的值，说明 p 和 q 都在当前节点的右子树中，因此向右子树移动。
   - 如果当前节点的值在 p 和 q 的值之间，或者等于 p 或 q 的值，那么当前节点就是 p 和 q 的最近公共祖先。

3. **重复上述步骤直到找到最近公共祖先**。

### 策略实施

- 使用递归或迭代方法遍历二叉搜索树。
- 保持算法的简洁性和效率，利用二叉搜索树的性质减少不必要的遍历。

### 详细设计

1. **递归方法**：
   - 定义一个递归函数，接受当前节点以及 p 和 q 作为参数。
   - 如果当前节点的值大于 p 和 q 的值，递归左子节点。
   - 如果当前节点的值小于 p 和 q 的值，递归右子节点。
   - 如果当前节点的值在 p 和 q 的值之间，返回当前节点作为最近公共祖先。

2. **迭代方法**：
   - 使用一个循环从根节点开始遍历。
   - 在循环中应用上述比较逻辑，根据 p 和 q 的值与当前节点的值的比较结果，移动到左子树或右子树。
   - 当找到满足条件的节点时，即为最近公共祖先，结束循环。

---