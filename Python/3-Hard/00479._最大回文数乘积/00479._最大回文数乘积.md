[479. 最大回文数乘积](https://leetcode.cn/problems/largest-palindrome-product)

[ChatGPT](https://chat.openai.com/share/2bc249a8-882b-4488-9b4f-f29fe1b217fb)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个整数 `n`，需要找到能够表示为两个 `n` 位数字乘积的最大回文数，并且返回这个回文数模 `1337` 的结果。

**1.2 示例**：
- 输入: `n = 2`
- 输出: `987`
  解释: `99 x 91 = 9009, 9009 % 1337 = 987`

**1.3 提示**:
- `n` 是一个正整数，并且在 1 到 8 的范围内。

## 2. 边界情况和约束
**边界情况**:
- 当 `n = 1` 时，最大的两个一位数的乘积是 `9 x 9 = 81`，回文数是 `9`，所以结果是 `9 % 1337 = 9`。
- 对于更大的 `n`，需要考虑的乘积范围显著增加，但是最大可能的回文数是由两个最大的 `n` 位数乘积构成的。

**约束**:
- 输入 `n` 的范围限制了可能的乘积范围，这有助于缩小搜索空间。
- 结果需要模 `1337`，这意味着即使是很大的回文数，最终结果也会被限制在一个相对小的数值范围内。


## 3. 算法和策略
1. **初始化最大数和最小数**:
   - 最大的 `n` 位数为 `10^n - 1`。
   - 最小的 `n` 位数为 `10^(n-1)`。

2. **构造回文数**:
   - 从最大的 `n` 位数开始，向下遍历。
   - 对于每个数，构造一个回文数。例如，如果当前数是 `123`，则构造的回文数可以是 `123321`。

3. **检查是否为乘积**:
   - 对于构造的每个回文数，检查是否可以分解为两个 `n` 位数的乘积。
   - 从最大的 `n` 位数开始尝试除以构造的回文数，直到找到一个整除的情况或者除数小于最小的 `n` 位数。

4. **取模并返回结果**:
   - 一旦找到合适的回文数，对其取模 `1337` 并返回结果。

5. **优化策略**:
   - 可以通过从大到小遍历回文数来减少搜索次数。
   - 判断乘积是否可能在尝试除法前，例如通过比较乘积的大小。

---