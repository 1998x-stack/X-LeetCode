[568. 最大休假天数](https://leetcode.cn/problems/maximum-vacation-days)

[ChatGPT](https://chat.openai.com/share/c3ca09e2-8836-4a38-b4ed-51dbc51d2118)

---

## 1. 问题的内容
**1.1 题目描述**：
- 给定两个矩阵 `flights` 和 `days`，表示航班和每个城市的休假天数。
- `flights[i][j]` 表示从城市 `i` 到城市 `j` 是否存在直飞航班（1 表示存在，0 表示不存在）。
- `days[i][j]` 表示在第 `j` 周可以在城市 `i` 休假的最大天数。
- 一开始在城市 0，每周可以选择留在当前城市或者飞往一个直飞的城市。
- 只能在周一飞行，且每周只能飞一次，目的是最大化休假天数。
- 不能在周六和周日飞行。
- 返回可以获得的最大休假天数。

**1.2 示例**：
- 输入: 
  - flights = [[0,1,1],[1,0,1],[1,1,0]]
  - days = [[1,3,1],[6,0,3],[3,3,3]]
- 输出: 12
- 解释: 可以第一周飞到城市 1，休假 6 天。第二周飞到城市 2，休假 3 天。第三周留在城市 2，再休假 3 天。

**1.3 提示**:
- 思考动态规划的方式来解决问题，考虑状态表示和状态转移。

## 2. 边界情况和约束
**边界情况**:
- 城市数量或周数为 0 的情况。
- 所有城市都没有航班连接的情况。
- 只有一周时间的情况，考虑最优选择。

**约束**:
- `flights` 矩阵和 `days` 矩阵的尺寸约束。
- 每周只能进行一次飞行，且只能在周一进行。
- 休假天数取决于所在城市和周数。


## 3. 算法和策略
1. **状态定义**:
   - 使用 `dp[i][j]` 表示第 `i` 周在城市 `j` 可以获得的最大休假天数。

2. **状态转移方程**:
   - `dp[i][j] = max(dp[i-1][k] + days[j][i])` 对于所有 `k`，其中 `flights[k][j] == 1` 或 `k == j`（即可以从城市 `k` 飞到 `j`，或者已经在城市 `j`）。

3. **初始化**:
   - `dp[0][j] = days[j][0]` 如果 `flights[0][j] == 1` 或 `j == 0`。

4. **遍历顺序**:
   - 首先按周遍历，然后遍历城市，最后根据可达城市更新状态。

5. **结果**:
   - 遍历完成后，`dp[n-1][j]` 中的最大值即为答案，其中 `n` 是周数。

---