[480. 滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median)

[ChatGPT](https://chat.openai.com/share/de85c45e-e5b7-45b9-abf7-c4951be9c271)

---

## 1. 问题的内容
**1.1 题目描述**：
- LeetCode 480 题目要求我们找出所有滑动窗口中的中位数。给定一个数组 `nums` 和一个滑动窗口的大小 `k`，窗口从数组的最左端滑动到最右端。每次窗口向右移动一位，计算当前窗口中所有元素的中位数。

**1.2 示例**：
- 输入: `nums = [1,3,-1,-3,5,3,6,7]`, `k = 3`
- 输出: `[1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]`
- 解释: 滑动窗口的位置和对应的中位数如下：
  - `[1 3 -1] -3 5 3 6 7` -> 中位数是 1
  - `1 [3 -1 -3] 5 3 6 7` -> 中位数是 -1
  - `1 3 [-1 -3 5] 3 6 7` -> 中位数是 -1
  - `1 3 -1 [-3 5 3] 6 7` -> 中位数是 3
  - `1 3 -1 -3 [5 3 6] 7` -> 中位数是 5
  - `1 3 -1 -3 5 [3 6 7]` -> 中位数是 6

**1.3 提示**:
- 你能不能在时间复杂度低于 O(nk) 的条件下解决此题？

## 2. 边界情况和约束
**边界情况**:
- `nums` 为空或 `k` 大于 `nums` 的长度。
- `k` 为 1 或等于 `nums` 的长度。
- `nums` 中包含重复元素。
- `nums` 的长度非常大，考虑到性能问题。

**约束**:
- 数组可能包含负数。
- 中位数的定义根据窗口中元素的数量确定：如果窗口中的元素数量是奇数，则中位数是中间的元素；如果窗口中的元素数量是偶数，则中位数是中间两个元素的平均值。


## 3. 算法和策略
为了解决时间复杂度低于 O(nk) 的要求，我们需要一个更高效的方法来维护窗口内元素的顺序并快速找到中位数。一种方法是使用两个堆（一个最大堆和一个最小堆）来维护窗口内元素，确保快速访问中位数。

**算法步骤**:
1. **初始化**: 创建一个最大堆和一个最小堆。最大堆用于存储窗口的较小一半元素，最小堆用于存储窗口的较大一半元素。确保最小堆的大小等于或比最大堆大1。
2. **添加元素至堆中**: 当一个新元素加入窗口时，比较这个元素与最大堆的最大元素。如果小于或等于最大堆的最大元素，将其加入最大堆；否则，加入最小堆。
3. **平衡两个堆**: 如果任一堆的大小超过另一堆的大小超过1，进行调整，将一个堆的顶部元素移动到另一个堆，直到两个堆的大小差不超过1。
4. **找到中位数**: 如果两个堆的总大小是偶数，中位数是两个堆顶元素的平均值；如果是奇数，中位数是元素较多的堆的堆顶元素。
5. **移动窗口**: 当窗口向右移动时，需要从堆中移除窗口最左边的元素。这需要检查该元素属于哪个堆，并从该堆中移除它，然后再次平衡两个堆。
6. **重复步骤2-5**，直到窗口遍历完数组。
---