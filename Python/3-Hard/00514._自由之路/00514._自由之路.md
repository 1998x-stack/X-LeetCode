[514. 自由之路](https://leetcode.cn/problems/freedom-trail)

[ChatGPT](https://chat.openai.com/share/b210ecdf-f31b-4af8-ae1d-e8e446b73467)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode题目514《自由之路》要求我们通过编程找到旋转圆盘最少的步数来拼写出给定的关键词。圆盘上有26个字母，从'A'到'Z'，每次可以顺时针或逆时针旋转圆盘来选择字母，目的是拼写出一个关键词。

- **输入**：一个字符串`ring`，表示圆盘上的字母顺序（从12点钟方向开始），和一个字符串`key`，表示需要拼写的关键词。
- **输出**：一个整数，表示拼写整个关键词需要的最少步数。

**1.2 示例**：
例如，如果圆盘`ring = "godding"`, 关键词`key = "gd"`，那么最少步数为4步：首先，从'g'旋转到'd'需要2步；然后，从'd'旋转回'g'需要2步。

**1.3 提示**:
- 圆盘上的字母可以重复。
- 旋转一步可以选择相邻的字母。
- 旋转是可以跨过圆盘的起点和终点的，即圆盘是环形的。


## 2. 边界情况和约束
**边界情况**：

- `ring`和`key`为空字符串。
- `ring`中只有一个字母，而`key`中包含多个不同的字母，这种情况下是无法拼写出关键词的。
- `key`中的字母在`ring`中不存在。

**约束**：

- `1 <= ring.length, key.length <= 100`
- `ring`和`key`仅由大写英文字母组成。


## 3. 算法和策略

1. **初始化状态数组**：创建一个二维数组`dp`，其中`dp[i][j]`表示从`key[i]`开始到关键词结束，圆盘指针在`ring[j]`位置时，需要的最少步数。
2. **边界条件**：对于最后一个字母`key[-1]`，需要遍历`ring`，直接计算每个位置到`key[-1]`的最少步数，并初始化到`dp[-1][j]`。
3. **状态转移**：对于`key[i]`（从倒数第二个字母开始向前），计算每个可能的`ring[j]`位置，通过比较所有可能的下一个状态（即下一个字母在`ring`中的所有位置）来选择最少步数。
4. **计算步数**：转动步数可以分为两部分，一是`ring[j]`到`key[i]`的最短距离，二是`dp[i+1][next_pos]`（即从下一个字母开始到结束的最少步数）。选择最小的步数加上到下一个字母的步数，更新`dp[i][j]`。
5. **结果**：最终，`dp[0][0]`就是从圆盘的初始位置（假设始终在`ring[0]`开始）拼写完整个`key`所需要的最少步数。
---

