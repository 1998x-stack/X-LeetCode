[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position)

[ChatGPT](https://chat.openai.com/share/1097a9df-0118-4af0-825c-06064b060f65)

---

## 1. 问题的内容
**1.1 题目描述**：
   - 题目要求我们找到一个给定目标值在一个排序数组中的插入位置，如果找到了目标值，则返回其索引；如果没有找到，则返回它按顺序插入的位置。
   - 我们必须假设数组中没有重复的元素。
   - 问题要求算法的时间复杂度应尽可能低。

**1.2 示例**：
   - 示例 1：输入：`nums = [1,3,5,6], target = 5`，输出：`2`。
   - 示例 2：输入：`nums = [1,3,5,6], target = 2`，输出：`1`。
   - 示例 3：输入：`nums = [1,3,5,6], target = 7`，输出：`4`。

**1.3 提示**:
   - 数组`nums`是按非递减顺序排序的。
   - `1 <= nums.length <= 10^4`
   - `-10^4 <= nums[i] <= 10^4`
   - `-10^4 <= target <= 10^4`

## 2. 边界情况和约束
1. **边界情况**：
   - `nums`数组为空时。
   - `target`值小于`nums`数组中的最小值时。
   - `target`值大于`nums`数组中的最大值时。

2. **约束**：
   - 数组长度的限制（`1 <= nums.length <= 10^4`）意味着算法需要处理大量数据的情况。
   - 值的范围限制（`-10^4 <= nums[i], target <= 10^4`）定义了输入值的可能范围。


## 3. 算法和策略

1. **选择算法**：
   - 由于数组是排序的，最适合的算法是**二分查找**，因为它的时间复杂度是`O(log n)`，可以高效地处理问题。

2. **算法设计**：
   - 初始化两个指针`left = 0`和`right = nums.length - 1`。
   - 当`left <= right`时，执行循环：
     - 计算中间位置`mid = left + (right - left) / 2`。
     - 如果`nums[mid] == target`，直接返回`mid`。
     - 如果`nums[mid] < target`，调整`left = mid + 1`。
     - 否则，调整`right = mid - 1`。
   - 如果循环结束后没有找到目标值，`left`将是`target`应当插入的位置，返回`left`。
---