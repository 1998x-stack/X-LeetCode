[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)

[ChatGPT](https://chat.openai.com/share/4712974e-e524-4894-9783-c080d25bced)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode题目[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)的核心任务是，给定一个升序排列的数组，你需要原地删除重复出现的元素，使得每个元素只出现一次，返回移除重复元素后数组的新长度。不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。

**1.2 示例**：
- 示例 1：
  输入：`nums = [1,1,2]`
  输出：返回长度 `2`, 数组的前两个元素被修改为 `1, 2`。不需要考虑数组中超出新长度后面的元素。
- 示例 2：
  输入：`nums = [0,0,1,1,1,2,2,3,3,4]`
  输出：返回长度 `5`, 数组的前五个元素被修改为 `0, 1, 2, 3, 4`。

**1.3 提示**:
- `0 <= nums.length <= 3 * 10^4`
- `-10^4 <= nums[i] <= 10^4`
- 数组是按照**升序排列**的。

## 2. 边界情况和约束

在解决[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)问题时，边界情况和约束条件是非常关键的，因为它们直接影响到算法的设计和实现。以下是对边界情况和约束的详细分析：

1. **数组长度的边界**：
   - 数组长度为0 (`nums.length == 0`)，此时数组中没有元素，因此不需要任何操作，直接返回0。
   - 数组长度为1 (`nums.length == 1`)，此时数组中只有一个元素，自然不存在重复元素，直接返回1。

2. **元素值的范围**：
   - 元素的值范围为`[-10^4, 10^4]`，这意味着需要考虑到整数的全范围处理，但实际上这对算法的设计影响不大，因为我们关注的是元素的相对大小和重复性，而不是具体的值。

3. **原地修改数组**：
   - 必须在原数组上操作，不得分配额外空间。这意味着算法的空间复杂度应为O(1)，即只能使用常数级别的额外空间。

4. **返回值**：
   - 函数需要返回移除重复元素后数组的新长度，这意味着我们不仅要在原地修改数组去除重复元素，还要计算并返回新的数组长度。

5. **数组已排序**：
   - 输入的数组是升序排列的，这是一个非常重要的信息，因为它允许我们使用双指针等技术高效地解决问题，利用数组的有序性可以大大简化查找和移除重复元素的过程。


## 3. 算法和策略

1. **初始化两个指针**：
   - `i`（慢指针）：起始位置0，用于遍历数组并作为修改数组的位置指示器。
   - `j`（快指针）：起始位置1，用于寻找下一个不重复的元素。

2. **遍历数组**：
   - 当`j`小于数组长度时，进行遍历。
   - 比较`nums[i]`和`nums[j]`的值：
     - 如果相等（意味着重复），则`j`向前移动一位，继续寻找下一个不重复的元素。
     - 如果不相等，说明找到了一个新的不重复元素，需要将这个元素移动到`i+1`的位置，然后`i`和`j`都向前移动一位。

3. **重复元素移除**：
   - 通过上述步骤，所有不重复的元素都被移动到了数组的前面，`i`的位置就是新数组的最后一个元素的位置。

4. **返回新数组长度**：
   - 由于`i`是最后一个不重复元素的位置，所以新数组的长度为`i+1`。

**详细步骤**：

- **Step 1**：初始化`i=0`。
- **Step 2**：使用一个for循环让`j`从1开始遍历至数组结束。
- **Step 3**：在循环中，如果`nums[j] != nums[i]`，则将`i`增加1，并将`nums[j]`的值赋给`nums[i]`。
- **Step 4**：循环结束后，`i+1`即为新数组的长度，因为`i`是最后一个不重复元素的索引。

这个算法的优点是空间复杂度为O(1)，时间复杂度为O(n)，其中n是数组的长度，因为每个元素只被遍历一次。
---