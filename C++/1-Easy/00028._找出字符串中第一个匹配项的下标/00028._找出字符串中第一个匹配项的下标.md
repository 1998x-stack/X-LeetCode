[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string)

[ChatGPT](https://chat.openai.com/share/3f8f6238-0f72-48a9-9e32-385827cbd82c)

---

## 1. 问题的内容
**1.1 题目描述**：
题目[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string)要求实现一个函数，该函数能够在字符串`haystack`中查找字符串`needle`第一次出现的位置，并返回其下标。如果`needle`不是`haystack`的一部分，则返回`-1`。

**1.2 示例**：
例如，给定`haystack = "sadbutsad", needle = "sad"`，函数应返回`0`，因为`"sad"`第一次出现在位置`0`。给定`haystack = "leetcode", needle = "leeto"`，函数应返回`-1`，因为`needle`不是`haystack`的一部分。

**1.3 提示**:
- 考虑使用双指针法或KMP算法来提高搜索效率。
- 注意处理边界情况，如空字符串或`needle`长度大于`haystack`长度的情况。

## 2. 边界情况和约束

#### 步骤 2.1: 边界情况

1. **空字符串处理**:
   - 当`needle`是空字符串时，根据常见的字符串处理逻辑，应返回`0`，因为空字符串可以被视为是任何字符串的子串，且出现在索引`0`的位置。
   - 当`haystack`为空而`needle`不为空时，应返回`-1`，因为非空字符串不能作为空字符串的子串。

2. **字符串长度**:
   - 当`needle`的长度大于`haystack`的长度时，显然`needle`不能是`haystack`的子串，因此应立即返回`-1`。

#### 步骤 2.2: 约束

1. **时间复杂度要求**:
   - 虽然题目没有明确指出时间复杂度的要求，但考虑到LeetCode的在线判题系统，我们需要设计一个尽可能高效的算法。暴力匹配的时间复杂度为O((N-M)M)，其中N是`haystack`的长度，M是`needle`的长度。对于较长的字符串，这可能不够高效。
   - KMP算法提供了一种时间复杂度为O(N+M)的解决方案，是更优的选择。

2. **空间复杂度要求**:
   - KMP算法需要额外的空间来存储部分匹配表（也称为π表或失败函数），其空间复杂度为O(M)，这在大多数情况下是可接受的。



## 3. 算法和策略

#### 步骤 3.1: 算法选择

- **暴力匹配**:
  - 暴力匹配算法通过在`haystack`中逐个检查每个可能的起始位置来查找`needle`。这种方法简单直接，但效率较低。

- **KMP算法**:
  - KMP (Knuth-Morris-Pratt) 算法利用已匹配的部分信息避免从头开始匹配，通过预处理`needle`来创建一个部分匹配表，这样可以在匹配失败时将`needle`滑动到合适的位置继续匹配，而无需回溯到`haystack`的前一个位置。

- **决定采用哪种**:
  - 考虑到效率和实际应用，我们选择**KMP算法**作为解决方案。

#### 步骤 3.2: 算法详细设计

1. **预处理`needle`**:
   - 创建部分匹配表，表中的每个值代表在`needle`中，前缀和后缀最长公共元素的长度。这有助于在发现不匹配时确定`needle`应该滑动多远。

2. **搜索过程**:
   - 使用两个指针分别遍历`haystack`和`needle`。
   - 当字符匹配时，两个指针都向前移动。
   - 当出现不匹配时，根据部分匹配表，移动`needle`的指针到正确的位置，而`haystack`的指针不回溯。

3. **匹配成功或失败的判断**:
   - 如果`needle`的指针移动到了其末尾，表示找到了完整的匹配，返回当前的起始位置。
   - 如果`haystack`的指针走到了末尾而没有找到匹配，则返回`-1`。
---
