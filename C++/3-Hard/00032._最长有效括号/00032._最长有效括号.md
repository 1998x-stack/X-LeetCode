[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses)

[ChatGPT](https://chat.openai.com/share/43b6bbca-a70e-411d-8b88-e161aae4d601)

---

## 1. 问题的内容
**1.1 题目描述**：
- **问题描述**: 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

**1.2 示例**：
- **示例1**:
  - 输入: "(()"
  - 输出: 2
  - 解释: 最长有效括号子串为 "()"

- **示例2**:
  - 输入: ")()())"
  - 输出: 4
  - 解释: 最长有效括号子串为 "()()"

**1.3 提示**:
- 字符串长度 n 的范围为 [0, 30000]。

## 2. 边界情况和约束
### 边界情况

1. **空字符串**: 输入字符串为空时，最长有效括号长度为0。
2. **全部为左括号或右括号**: 如 "((((" 或 "))))", 这种情况下最长有效括号长度为0。
3. **完全匹配的括号字符串**: 如 "()()()", 最长有效长度即为字符串的长度。
4. **字符串长度为1**: 任何单个括号都不可能形成有效的括号对，因此长度为1。

### 约束

1. 输入仅限于 '(' 和 ')'。
2. 字符串长度范围为 [0, 30000]。


## 3. 算法和策略
### 算法描述

使用动态规划解决此问题：

1. **初始化**:
   - 创建一个和输入字符串长度相同的数组 dp，所有元素初始化为0。dp[i] 表示以 i 结尾的最长有效括号的长度。
   - 设置一个变量 maxLength 为0，用于存储最长有效括号的长度。

2. **遍历字符串**:
   - 从第二个字符开始遍历字符串，因为单个字符不可能形成有效的括号对。
   - 如果当前字符是 ')'，则需要检查它之前的字符：
     - 如果前一个字符是 '('，则形成了一对有效的括号。`dp[i] = dp[i-2] + 2`。
     - 如果前一个字符也是 ')' 且 `i - dp[i-1] - 1` 位置的字符是 '('，则当前 ')' 可以和它形成一对有效的括号。`dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`。

3. **更新最长有效括号长度**:
   - 在每次遍历过程中，更新 maxLength 为 `max(maxLength, dp[i])`。

4. **返回结果**:
   - 遍历结束后，maxLength 即为最长有效括号的长度。

### 策略

- **动态规划**是解决此问题的关键，可以有效处理各种边界情况。
- 仔细处理边界条件，特别是数组的索引，防止越界。

---