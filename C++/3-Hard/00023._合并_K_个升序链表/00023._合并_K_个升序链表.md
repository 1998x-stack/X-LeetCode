[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists)

[ChatGPT](https://chat.openai.com/share/2d31b121-9f01-4b77-827d-88fde6395607)

---

## 1. 问题的内容
**1.1 题目描述**：
合并 *k* 个升序链表，返回合并后的排序链表以最小化总排序时间。

**1.2 示例**：
- 输入：lists = [[1,4,5],[1,3,4],[2,6]]
- 输出：[1,1,2,3,4,4,5,6]
解释：链表数组如上所述，合并这些链表，我们得到一个新的链表，其顺序为 [1,1,2,3,4,4,5,6]。

**1.3 提示**:
- k == lists.length
- 0 <= k <= 10^4
- 0 <= lists[i].length <= 500
- -10^4 <= lists[i][j] <= 10^4
- lists[i] 按升序排列
- lists[i].length 的总和不超过 10^4

## 2. 边界情况和约束
**边界情况**:
- `lists` 为空，即没有链表需要合并。
- 某个链表为空，即 `lists` 中某些位置可能不包含链表。
- 所有链表中只有一个非空链表。

**约束**:
- 链表元素的值范围为 [-10^4, 10^4]。
- 每个链表的长度最大为 500，考虑到内存和时间效率。
- `k` 的最大值为 10^4，需要注意合并算法的时间复杂度。


## 3. 算法和策略
为了解决这个问题，我们可以使用**分治法**。分治法是一种解决问题的方法，它将一个复杂的问题分解成两个或更多的相同或相似的子问题，直到这些子问题变得足够简单，可以直接解决。对于合并 k 个升序链表的问题，我们可以将 k 个链表分成两半，分别合并，然后再将合并后的结果合并。这种方法的好处是可以通过并行处理来减少处理时间。

**算法步骤**:
1. **递归分治**:
   - 如果链表数组为空，返回 null。
   - 如果链表数组中只有一个链表，直接返回这个链表。
   - 将链表数组分成两半，对每一半递归地应用合并算法。
2. **合并两个升序链表**:
   - 创建一个虚拟头节点，用来简化边界条件处理和结果链表的构建。
   - 比较两个链表头部的值，较小者接在结果链表的后面，然后移动较小值的链表的指针到下一个节点。
   - 重复上述过程，直到某一个链表为空。
   - 将非空链表的剩余部分接在结果链表的后面。
   - 返回虚拟头节点的下一个节点，即合并后链表的头节点。

**时间复杂度分析**:
- 设 n 是所有链表中元素的总数，k 是链表的数量。
- 分治合并的时间复杂度为 O(log k)，每次合并操作需要 O(n) 时间。
- 整体时间复杂度为 O(n log k)。

**空间复杂度分析**:
- 递归调用的栈空间，最坏情况下为 O(log k)。

---