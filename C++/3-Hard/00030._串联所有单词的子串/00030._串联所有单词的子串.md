[30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words)

[ChatGPT](https://chat.openai.com/share/2c5405a5-dd77-4b17-bcf8-91bea90ee14b)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode问题30，"串联所有单词的子串"，要求找出在给定字符串中所有单词串联形成的子串的起始索引。每个单词的长度都相同。

**1.2 示例**：
- **输入**: s = "barfoothefoobarman", words = ["foo","bar"]
- **输出**: [0,9]
- 解释: 从索引0和9开始的子串分别是"barfoor"和"foobar"。顺序不影响结果。

**1.3 提示**:
- 所有单词的长度相同。
- 单词的顺序可以任意。
- 结果中的索引应该按照数字顺序排列。

## 2. 边界情况和约束
#### 边界情况

1. **输入字符串为空**：返回空列表。
2. **单词列表为空**：返回空列表。
3. **单词长度总和大于输入字符串长度**：返回空列表。

#### 约束

1. 所有单词长度相同。
2. 单词列表中可能包含重复单词。


## 3. 算法和策略
#### 算法设计

1. **初始化**：创建一个哈希表来存储单词列表中每个单词出现的次数。
2. **遍历**：由于所有单词长度相同，可以使用固定长度的滑动窗口来遍历输入字符串。
3. **匹配**：在每个可能的起始位置，检查是否可以通过连续的单词匹配整个窗口。
4. **更新结果**：如果在某个起始位置可以匹配所有单词，则将该起始位置加入结果列表。

#### 策略详解

- 使用双重循环：
  - 外循环遍历字符串的每一个可能的起始位置。
  - 内循环用于检查从当前起始位置开始的子串是否符合条件。
- 使用一个临时哈希表来存储当前窗口中单词的出现次数，与原始哈希表进行比较，确保匹配所有单词。

---
