[10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching)

[ChatGPT](https://chat.openai.com/share/3e217982-fa88-4247-b5f8-1ece4f11d48d)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode问题[10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching)要求实现一个支持'.'和'*'的正则表达式匹配功能。其中，'.' 匹配任意单个字符，而'*' 匹配零个或多个前面的那一个元素。匹配应该覆盖整个输入字符串（不是部分）。

**1.2 示例**：
- 示例1:
  - 输入: s = "aa", p = "a"
  - 输出: false
  - 解释: "a" 无法匹配 "aa" 整个字符串。
  
- 示例2:
  - 输入: s = "aa", p = "a*"
  - 输出: true
  - 解释: 因为 '*' 表示零个或多个前面的那个元素, 这里的元素是 'a'。因此，字符串 "aa" 可以被视为 'a' 重复了一次。

- 示例3:
  - 输入: s = "ab", p = ".*"
  - 输出: true
  - 解释: ".*" 表示可以匹配零个或多个（'*'）任意字符（'.'）。

**1.3 提示**:
- `0 <= s.length <= 20`
- `0 <= p.length <= 30`
- `s` 只包含从 `a-z` 的小写字母。
- `p` 只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。
- 保证每次出现字符 `*` 时，前面都匹配到有效的字符。

## 2. 边界情况和约束
### 边界情况：

1. 当 `s` 或 `p` 是空字符串时的处理。
2. 当 `p` 以 `*` 开头时，这是非法的，因为 `*` 需要一个前置字符。
3. 当 `s` 和 `p` 都为空字符串时，应返回 `true`。
4. 当 `p` 中的 `*` 匹配零个前置字符时的情况。
5. 当 `p` 中的 `*` 匹配多个前置字符时的情况。

### 约束：

1. `s` 和 `p` 的长度限制，这影响到算法的时间和空间复杂度。
2. 字符集限制为小写字母 `a-z` 以及特殊字符 `.` 和 `*`，简化了问题但也限定了处理的范围。
3. `*` 前面必须有有效字符，这影响到 `p` 的解析方式。


## 3. 算法和策略
### 动态规划算法设计：

1. **定义状态**：`dp[i][j]` 表示 `s` 的前 `i` 个字符和 `p` 的前 `j` 个字符是否能够匹配。
2. **初始化**：
   - `dp[0][0] = true`，因为两个空字符串是匹配的。
   - `dp[i][0] = false`，当 `i > 0`，空的正则表达式不能匹配非空字符串。
   - `dp[0][j]`，当 `j > 0`，只有当 `p` 的偶数位置是 `*` 时才可能为 `true`，表示 `*` 匹配零个字符。
3. **状态转移方程**：
   - 如果 `s[i] == p[j]` 或 `p[j] == '.'`，则 `dp[i][j] = dp[i-1][j-1]`。
   - 如果 `p[j] == '*'`，则有两种情况：
     - 将 `*` 和它前面的字符看作空，即 `dp[i][j] = dp[i][j-2]`。
     - 将 `*` 前面的字符与 `s[i]` 匹配，如果 `s[i] == p[j-1]` 或 `p[j-1] == '.'`，则 `dp[i][j] = dp[i-1][j]`。
4. **返回结果**：`dp[s.length][p.length]`。

---