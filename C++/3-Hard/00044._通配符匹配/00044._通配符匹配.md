[44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching)

[ChatGPT](https://chat.openai.com/share/2825cfd3-9d2d-4c31-acde-58318dbb6f0f)

---

## 1. 问题的内容
**1.1 题目描述**：
- 问题来自 LeetCode，题号 44，题目为“通配符匹配”。
- 给定一个字符串 (s) 和一个字符模式 (p)，实现一个支持 '?' 和 '*' 的通配符匹配。
  - '?' 可以匹配任何单个字符。
  - '*' 可以匹配任意字符串（包括空字符串）。
- 两个字符串完全匹配才算匹配成功。

**1.2 示例**：
1. 输入: s = "aa", p = "a"
   输出: False
   解释: "a" 无法匹配 "aa" 整个字符串。

2. 输入: s = "aa", p = "*"
   输出: True
   解释: '*' 可以匹配任意字符串。

3. 输入: s = "cb", p = "?a"
   输出: False
   解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。

4. 输入: s = "adceb", p = "*a*b"
   输出: True
   解释: 第一个 '*' 可以匹配空字符串, 'a' 匹配 'a', 第二个 '*' 匹配 "dce", 'b' 匹配 'b'。

**1.3 提示**:
- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

## 2. 边界情况和约束
**边界情况**:
1. s 或 p 为空字符串。
2. p 字符串全为 '*'。
3. s 和 p 都不包含通配符。
4. p 中 '?' 和 '*' 的组合使用。

**约束**:
1. 字符串长度 s <= 2000, p <= 2000。
2. '?' 只匹配单一字符，'*' 匹配零个或多个任意字符。

## 3. 算法和策略
1. **动态规划**:
   - 创建一个布尔类型的二维数组 dp，其中 dp[i][j] 表示 s 的前 i 个字符与 p 的前 j 个字符是否匹配。
   - 初始化 dp[0][0] 为 true，表示两个空字符串匹配。
   - 对于 p 的前 j 个字符全为 '*' 的情况，设置 dp[0][j] 为 true。
   - 遍历 s 和 p，对于每一对字符 (s[i], p[j])，进行如下判断：
     - 如果 p[j] == s[i] 或 p[j] == '?'，则 dp[i][j] = dp[i-1][j-1]。
     - 如果 p[j] == '*'，则 dp[i][j] = dp[i][j-1] (不使用 '*') 或 dp[i-1][j] (使用 '*')。
   - 最后，dp[s.length()][p.length()] 即为所求的答案。

2. **策略优化**:
   - 使用滚动数组减少空间复杂度，只保留当前行和上一行的状态。

---