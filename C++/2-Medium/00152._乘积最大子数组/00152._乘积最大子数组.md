[152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray)

[ChatGPT](https://chat.openai.com/share/1793e4c2-7e43-45f5-8fe4-756418ebb146)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode问题152题目『乘积最大子数组』要求我们找出一个整数数组中，乘积最大的连续子数组（该子数组至少包含一个数字），并返回该子数组的乘积。

**1.2 示例**：
- **输入**: `nums = [2,3,-2,4]`
- **输出**: `6`
- **解释**: 子数组 `[2,3]` 有最大乘积 `6`。

- **输入**: `nums = [-2,0,-1]`
- **输出**: `0`
- **解释**: 结果不能为 `2`, 因为 `[-2,-1]` 不是子数组，它们之间有 `0` 隔开。

**1.3 提示**:
- `1 <= nums.length <= 2 * 10^4`
- `-10 <= nums[i] <= 10`
- 数组中的每个元素都是整数。

## 2. 边界情况和约束
- 数组长度为1时，直接返回该元素。
- 数组中包含0时，0将数组分割为多个部分，每部分独立考虑。
- 数组中包含负数时，偶数个负数乘积为正，奇数个负数则需要考虑舍弃哪一个负数以获得最大乘积。
- 数组全为正数或全为负数。


## 3. 算法和策略
#### 算法思路
使用动态规划解决。维护两个变量`imax`和`imin`，分别记录到当前位置为止，包含当前元素的最大乘积和最小乘积（考虑到负负得正，最小乘积乘以一个负数可能变为最大）。

- **初始化**：`imax = imin = nums[0]`, 最大乘积`maxProduct = nums[0]`
- **遍历数组**：从`nums[1]`开始，对于每个`nums[i]`，
  - 如果`nums[i]`是负数，交换`imax`和`imin`（因为负数会使最大变最小，最小变最大）
  - 更新`imax`和`imin`
    - `imax = max(nums[i], imax * nums[i])`
    - `imin = min(nums[i], imin * nums[i])`
  - 更新`maxProduct = max(maxProduct, imax)`

#### 策略细节
- 注意处理数组中0的情况，每次遇到0时，重置`imax`和`imin`为1（因为任何数乘以0都为0，这相当于重新开始）。
- 考虑数组中负数的情况，通过交换`imax`和`imin`来应对。

---
