[46. 全排列](https://leetcode.cn/problems/permutations)

[ChatGPT](https://chat.openai.com/g/g-GsMNEr76r-c-master)

---

## 1. 问题的内容
**1.1 题目描述**：
- LeetCode上的问题编号46，题目是“全排列”。
- 给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。
- 你可以按任意顺序返回答案。

**1.2 示例**：
- 输入：`nums = [1,2,3]`
- 输出：`[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]`

**1.3 提示**:
- 给定数组的长度范围是 `[1, 6]`。
- 数组中的元素是无重复的，范围在 `[1, 6]` 内。

## 2. 边界情况和约束
**边界情况**：
1. 数组只含有一个元素，这时全排列只有一个，即其自身。
2. 数组含有6个元素，这是问题规定的最大范围，需要确保算法能高效处理。

**约束**：
1. 数组元素无重复，简化了去重步骤。
2. 元素值范围和数组长度的限制减少了潜在的特殊情况处理。


## 3. 算法和策略
1. **使用递归回溯算法**：
   - 回溯算法是解决全排列问题的经典方法，通过递归来实现深度优先搜索。

2. **算法步骤**：
   - **初始化**：创建一个空列表 `res` 用于存储所有排列结果，创建一个临时列表 `path` 用于存储当前路径（即一种排列）。
   - **递归函数定义**：编写一个递归函数 `backtrack(nums, path, res)`，其中 `nums` 是输入数组，`path` 是当前路径，`res` 是所有排列的结果列表。
   - **递归终止条件**：当 `path` 的长度等于 `nums` 的长度时，将 `path` 添加到 `res` 中，并返回。
   - **遍历**：遍历 `nums` 中的每个元素，如果该元素已经在 `path` 中，就跳过，否则添加到 `path` 中，并继续递归调用 `backtrack`，之后将其从 `path` 中移除（回溯）。

---
