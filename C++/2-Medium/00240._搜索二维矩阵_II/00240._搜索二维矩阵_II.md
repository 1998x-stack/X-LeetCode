[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii)

[ChatGPT](https://chat.openai.com/share/1a482f16-a430-41b6-8740-3943609d390b)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode 240题目要求我们在一个二维矩阵中搜索一个给定的值。这个矩阵有以下特点：
- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**1.2 示例**：
例如，考虑以下矩阵：
```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```
给定目标值 `target = 5`，返回 `true`。
给定目标值 `target = 20`，返回 `false`。

**1.3 提示**:
- 你可以假设矩阵不为空，并且其内的元素都是整数。
- 尝试使用高效的算法来解决这个问题。


## 2. 边界情况和约束
#### 边界情况
- **矩阵为空**：如果给定的矩阵为空，那么任何搜索都应该立即返回 `false`。
- **矩阵仅含一行或一列**：这种情况下，算法应能正确处理仅进行一维搜索。
- **目标值小于矩阵中的最小值或大于最大值**：在这种情况下，可以直接返回 `false`，不需要搜索整个矩阵。

#### 约束
- 矩阵中的行数和列数可能非常大，需要注意算法的时间复杂度和空间复杂度。
- 要在保证算法效率的同时，尽可能减少不必要的搜索。

## 3. 算法和策略

#### 算法设计
考虑到矩阵的特点，我们可以采用一种从右上角（或左下角）开始搜索的方法：
1. **初始位置定位**：将搜索起点定位在右上角（或左下角），这里以右上角为例。
2. **搜索过程**：
   - 如果当前元素等于目标值，返回 `true`。
   - 如果当前元素小于目标值，向下移动（因为向右移动不可能找到目标值）。
   - 如果当前元素大于目标值，向左移动（因为向下移动不可能找到目标值）。
3. **结束条件**：如果我们超出了矩阵的边界，则说明矩阵中不存在目标值，返回 `false`。

#### 策略
- **时间复杂度**：此算法的时间复杂度为 O(m+n)，其中 m 是矩阵的行数，n 是矩阵的列数。
- **空间复杂度**：O(1)，不需要额外的存储空间。

---
