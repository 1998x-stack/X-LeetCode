[280. 摆动排序](https://leetcode.cn/problems/wiggle-sort)

[ChatGPT](https://chat.openai.com/share/ad4a3c19-7dc5-4cb4-bc89-f6e24eab1fda)

---

## 1. 问题的内容
**1.1 题目描述**：
给你一个无序的数组 `nums`，将该数组重新排列后使得 `nums[0] <= nums[1] >= nums[2] <= nums[3]...`。

换句话说，`nums` 中的元素应该按照一个摆动的顺序排列，即小于、大于、小于、大于...这样的顺序。这里的排序不要求每个元素具有全局的顺序，只需要保证局部的摆动顺序即可。

**1.2 示例**：
例如，给定数组 `nums = [3, 5, 2, 1, 6, 4]`，一个可能的摆动排序后的数组是 `[1, 6, 2, 5, 3, 4]`。

**1.3 提示**:
- 你可以假设所有输入都会有有效的解。
- 尝试不使用额外的空间来解决问题。

## 2. 边界情况和约束

### 边界情况

1. **空数组或单元素数组**：这样的数组已经满足摆动排序的要求，无需任何操作。
2. **所有元素相等的数组**：同样满足摆动排序的要求，因为所有元素都等于其相邻元素。
3. **仅有两个元素的数组**：只需要比较这两个元素，如果不满足条件，交换它们即可。

### 约束

1. **原地排序**：需要在不使用额外空间的前提下完成摆动排序。
2. **时间复杂度**：尽可能寻找时间复杂度低的解法。
3. **稳定性**：摆动排序不要求稳定性，因为元素间的相对顺序可以改变。


## 3. 算法和策略
1. **遍历数组**：从头到尾遍历数组。
2. **判断条件**：对于每个索引 `i`，如果 `i` 是偶数，则确保 `nums[i] <= nums[i+1]`；如果 `i` 是奇数，则确保 `nums[i] >= nums[i+1]`。
3. **交换元素**：如果上述条件不满足，则交换 `nums[i]` 和 `nums[i+1]`。

### 算法细节

- **初始化**：从数组的第一个元素开始，索引 `i = 0`。
- **遍历与交换**：对于数组中的每个元素（除了最后一个），根据索引的奇偶性判断应该应用的条件，并进行可能的交换。
- **结束条件**：当遍历完数组中的所有元素时，算法结束。

---
