[146. LRU 缓存](https://leetcode.cn/problems/lru-cache)

[ChatGPT](https://chat.openai.com/share/98a406c5-d978-443b-8d4a-b6bc0400e05d)

---

## 1. 问题的内容
**1.1 题目描述**：
设计一个数据结构，实现 LRU (最近最少使用) 缓存机制。这个数据结构必须提供以下功能：

- `get(key)`：如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
- `put(key, value)`：如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

**1.2 示例**：
```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]

输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使关键字 1 作废，缓存是 {3=3, 4=4}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```


**1.3 提示**:
- 最好能够在 O(1) 时间复杂度内完成 `get` 和 `put` 操作。

## 2. 边界情况和约束
- **缓存容量**: 缓存的容量 (`capacity`) 是一个正整数，并且可以假设在所有的操作中，`0 < capacity <= 3000`。
- **键和值的范围**: 可以假设 `key` 和 `value` 都是正整数，且 `0 < key, value <= 10^4`。
- **操作数量限制**: 在最坏的情况下，操作数量将在 `2 <= operations <= 10^5` 范围内。
- **时间复杂度**: 对于 `get` 和 `put` 操作的时间复杂度应为 O(1)。

## 3. 算法和策略
要满足 O(1) 时间复杂度的要求，推荐使用双向链表（LinkedList）和哈希表（HashMap）的结合。双向链表用于实现 LRU 缓存的顺序，哈希表则用于保证快速访问。

1. **数据结构设计**:
   - 使用双向链表存储缓存中的键值对，链表的头部表示最近使用的元素，尾部表示最久未使用的元素。
   - 使用哈希表存储键与对应链表节点的映射，从而实现 O(1) 时间复杂度的访问。

2. **get操作**:
   - 如果键存在于哈希表中，则表示缓存命中。
     - 获取哈希表中的链表节点。
     - 将该节点移动到链表头部，表示最近被访问。
     - 返回节点的值。
   - 如果键不存在，返回 -1。

3. **put操作**:
   - 如果键已存在于哈希表中：
     - 更新节点的值。
     - 将该节点移动到链表头部。
   - 如果键不存在：
     - 创建一个新的链表节点，并将其加入到链表头部。
     - 将键和新节点加入到哈希表中。
     - 如果加入新节点后链表长度超过容量：
       - 删除链表尾部节点，同时也从哈希表中移除对应的键。

4. **删除最久未使用元素**:
   - 删除链表尾部的节点，并在哈希表中移除对应的键值对。

---