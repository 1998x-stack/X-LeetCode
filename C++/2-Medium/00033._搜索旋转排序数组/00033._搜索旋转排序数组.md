[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array)

[ChatGPT](https://chat.openai.com/g/g-GsMNEr76r-c-master)

---

## 1. 问题的内容
**1.1 题目描述**：
**搜索旋转排序数组**问题的核心是在一个经过旋转的有序数组中寻找一个特定的目标值。如果目标值存在，则返回它的索引，否则返回-1。你可以假设数组中不存在重复的元素。

**1.2 示例**：
假设我们有以下旋转排序数组和目标值：

- 数组：`[4,5,6,7,0,1,2]`
- 目标值：`0`

在这个例子中，目标值`0`存在于数组中，并且它的索引为`4`。

**1.3 提示**:
- 尝试使用二分查找法来解决这个问题，这是因为即使数组被旋转，我们仍然可以找到一种方式，通过比较中间元素与数组两端的元素，确定目标值可能存在的区域。
- 考虑到旋转的特性，数组可以被看作是两个排序的子数组。通过比较中点与端点的值，可以确定哪一半是有序的。
- 在有序的半边中使用二分查找法查找目标值。如果目标值不在有序的半边中，那么它必定在另一半中。

## 2. 边界情况和约束
**边界情况**:

1. **数组长度为1**：这种情况下，直接比较数组唯一的元素与目标值即可。
2. **数组未旋转**：即使数组被标记为旋转排序数组，也可能实际上未旋转，即整个数组是有序的。这种情况下，直接应用标准的二分查找即可。
3. **目标值在最小值左边或右边**：需要确定目标值是位于旋转点左侧的递增序列中，还是位于右侧的递增序列中。

**约束**:

- 数组中不存在重复的元素，这简化了问题，因为不必担心找到重复元素的情况。
- 时间复杂度应尽可能低，最理想的情况是O(log n)，即二分查找的时间复杂度。


## 3. 算法和策略
我们将采取的策略是二分查找法，但是要对其进行适当的修改，以处理数组的旋转特性。

**算法步骤**:

1. **初始化**：设置两个指针，`left` 和 `right`，分别指向数组的起始位置和结束位置。
2. **二分查找**：计算中间位置 `mid = (left + right) / 2`。
3. **判断逻辑**：
   - 如果 `nums[mid]` 等于 `target`，直接返回 `mid`。
   - 接下来判断哪一半是有序的：
     - 如果 `nums[left] <= nums[mid]`，则左半部分是有序的。
       - 如果 `target` 在 `nums[left]` 和 `nums[mid]` 之间，调整 `right` 到 `mid - 1`。
       - 否则，调整 `left` 到 `mid + 1`。
     - 否则，右半部分是有序的。
       - 如果 `target` 在 `nums[mid]` 和 `nums[right]` 之间，调整 `left` 到 `mid + 1`。
       - 否则，调整 `right` 到 `mid - 1`。
4. **重复**：重复以上步骤，直到找到目标值或者 `left > right`。

**注意**：在每一步中，都要小心处理边界条件和比较逻辑，确保不会错过目标值。

---