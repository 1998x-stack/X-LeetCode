[277. 搜寻名人](https://leetcode.cn/problems/find-the-celebrity)

[ChatGPT](https://chat.openai.com/share/78322a43-5a6d-4974-a0ba-19ab4859bc5f)

---

## 1. 问题的内容
**1.1 题目描述**：
假设你是一个专业的聚会组织者，想要在一次聚会中找出名人。聚会中有 n 个人，编号从 0 到 n - 1。在这个聚会中，可能存在一位名人。名人的定义是所有其他 n-1 个人都认识他/她，但他/她不认识任何其他人。

你将获得一个API `bool knows(a, b)`，该API会返回 true 当且仅当人员 a 认识人员 b。利用这个API，你需要找出聚会中的名人。

请注意，调用 `knows` API 的次数应尽可能少。

**函数签名**：

```cpp
int findCelebrity(int n);
```

**1.2 示例**：
- 输入：`n = 3`，假设 `knows` API 的内部实现如下：

    ```cpp
    knows(0, 1) -> true
    knows(1, 0) -> false
    knows(0, 2) -> true
    knows(2, 0) -> false
    knows(1, 2) -> true
    knows(2, 1) -> false
    ```

- 输出：`1`（解释：人员 1 是名人，因为每个人都认识他，但他不认识任何人）

**1.3 提示**:
- `n` 的范围是 `[1, 100]`。
- `knows` API 的调用次数限制不在题目中给出，但你需要尽量减少调用次数。

## 2. 边界情况和约束
**边界情况**：

1. **只有一个人**：当只有一个人时，根据题目定义，这个人既不能是名人（因为没有其他人认识他）也不能不是名人（因为他不需要认识自己）。这种情况下应返回无名人 `-1`。
2. **所有人都不是名人**：如果每个人至少认识一个人，那么不存在名人。
3. **存在多于一人认识所有人但所有人也认识至少一个其他人**：这种情况下，也不存在名人。

**约束**：

1. `knows` API 的调用次数应尽可能少，以提高算法的效率。
2. 不能直接访问内部信息，只能通过 `knows` API 来判断一个人是否认识另一个人。


## 3. 算法和策略
**算法步骤**：

1. **初始化候选人为0**：假设第一个人（编号0）可能是名人。
2. **一次遍历确认可能的名人**：遍历所有人，使用 `knows` API 检查当前候选人是否认识其他人。
    - 如果候选人认识某人，则候选人肯定不是名人，将这个“某人”设为新的候选人。
    - 继续遍历直到结束，这样可以保证最后的候选人是唯一可能是名人的人。
3. **二次遍历验证候选人是否为名人**：
    - 检查是否所有其他人都认识候选人，并且候选人不认识任何其他人。
    - 如果两个条件都满足，则候选人是名人；否则，没有名人。

**策略特点**：

- 通过两次遍历来确保找到的候选人是唯一可能的名人，同时最小化 `knows` API 的调用次数。
- 第一次遍历主要用于缩小可能的名人范围，第二次遍历用于验证候选人是否满足名人条件。

---
