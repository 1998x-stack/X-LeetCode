[334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence)

[ChatGPT](https://chat.openai.com/g/g-GsMNEr76r-c-master)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个未排序的数组 `nums`，判断这个数组是否存在一个由三个元素组成的严格递增子序列。如果存在这样的三个索引 `i`、`j`、`k`，且满足 `0 <= i < j < k < n`，使得 `nums[i] < nums[j] < nums[k]`，返回 `true`；否则，返回 `false`。

**1.2 示例**：
- 示例 1：
  输入：`nums = [1,2,3,4,5]`
  输出：`true`
  解释：任何 `i < j < k` 的序列 `(0,-,-,1,-)` 都满足条件 `nums[i] < nums[j] < nums[k]`。

- 示例 2：
  输入：`nums = [5,4,3,2,1]`
  输出：`false`
  解释：不存在满足条件的三元子序列。

- 示例 3：
  输入：`nums = [2,1,5,0,4,6]`
  输出：`true`
  解释：子序列 `(0, - ,1, - , - , 2)` 满足条件 `nums[0] < nums[2] < nums[5]`。

**1.3 提示**:
- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`

## 2. 边界情况和约束
#### 边界情况
- 数组长度小于3：此时无法构成三元子序列，直接返回`false`。
- 数组长度等于或大于3：需要进一步分析数组中的元素以判断是否存在递增的三元子序列。

#### 约束
- 数组元素的取值范围为整型范围，即`-2^31`到`2^31-1`，需要考虑整数溢出问题。
- 数组未排序，不能直接应用有序数组的方法，需考虑无序环境下的解决方案。


## 3. 算法和策略
为了解决这个问题，我们可以使用一个非常高效的线性时间复杂度的算法。这个算法的核心思想是维护两个变量`first`和`second`，分别用来记录遍历过程中遇到的最小值和第二小的值。算法的基本步骤如下：

1. 初始化`first = INT_MAX`和`second = INT_MAX`。
2. 遍历数组`nums`：
   - 如果`nums[i] <= first`，则更新`first = nums[i]`。这意味着我们找到了当前遍历过程中的最小值。
   - 否则，如果`nums[i] <= second`，则更新`second = nums[i]`。这意味着我们找到了比`first`大但在所有遍历元素中第二小的值。
   - 否则，如果找到一个元素比`first`和`second`都大，这意味着我们找到了一个递增的三元子序列，可以直接返回`true`。
3. 如果遍历完成后没有返回`true`，意味着不存在递增的三元子序列，返回`false`。

这个算法的关键在于，它通过线性遍历一次数组就能找出是否存在递增的三元子序列，而不需要使用复杂的数据结构或高级算法。

---