[279. 完全平方数](https://leetcode.cn/problems/perfect-squares)

[ChatGPT](https://chat.openai.com/share/2dc78342-af6d-4bce-905f-d236644c6b1b)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个正整数 `n`，找出可以将其表示为若干个（至少一个）完全平方数之和的完全平方数的最小数量。完全平方数是其平方根为整数的正整数（例如，1, 4, 9, 16, ...）。

**1.2 示例**：
  - 输入：`n = 12`
  - 输出：`3`
  - 解释：12 = 4 + 4 + 4，最少需要三个完全平方数。

  - 输入：`n = 13`
  - 输出：`2`
  - 解释：13 = 4 + 9，最少需要两个完全平方数。

**1.3 提示**:
`1 <= n <= 10^4`，输入保证在整数范围内。

## 2. 边界情况和约束
- **边界情况**：
  - 最小的情况：`n = 1`，即输入为最小的正整数，此时输出也应为1，因为1本身就是一个完全平方数。
  - 最大的情况：`n = 10^4`，需要考虑算法的时间和空间复杂度是否能够在合理的时间内处理最大的输入值。

- **约束**：
  - 输入的 `n` 是一个正整数，意味着 `n >= 1`。
  - 输出是一个整数，表示最小的完全平方数数量。
  - 需要考虑算法的效率和性能，确保能够处理上限为 `10^4` 的输入。


## 3. 算法和策略
- **动态规划算法设计**：
  1. 初始化一个大小为 `n+1` 的数组 `dp`，其中 `dp[i]` 表示数字 `i` 能够被分解的最少完全平方数数量。初始化除 `dp[0]` 外的所有值为无穷大（INT_MAX），`dp[0]=0` 因为0不需要任何数字就可以表示。
  2. 遍历从1到n的每个数 `i`，对于每个 `i`，遍历所有可能的完全平方数 `j*j`（其中 `j*j <= i`），更新 `dp[i] = min(dp[i], dp[i-j*j] + 1)`。这一步是在寻找最小的完全平方数数量，使得其和为 `i`。
  3. 最终，`dp[n]` 即为我们要找的答案。

这个策略的核心是，对于每个数字 `i`，我们尝试减去一个完全平方数 `j*j`，然后到 `dp` 数组中查找剩余部分 `i-j*j` 的最小分解数量，再加上我们刚才减去的那个完全平方数（即加1），从而更新 `dp[i]`。

---
