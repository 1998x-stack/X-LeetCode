[155. 最小栈](https://leetcode.cn/problems/min-stack)

[ChatGPT](https://chat.openai.com/g/g-GsMNEr76r-c-master)

---

## 1. 问题的内容
**1.1 题目描述**：
设计一个支持 `push`，`pop`，`top` 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` -- 将元素 x 推入栈中。
- `pop()` -- 删除栈顶的元素。
- `top()` -- 获取栈顶元素。
- `getMin()` -- 检索栈中的最小元素。

**1.2 示例**：
**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**1.3 提示**:
1. 栈的元素类型为整数。
2. 注意考虑栈操作可能涉及到的边界情况，例如栈空时进行 `pop` 或 `getMin` 操作。

## 2. 边界情况和约束
### 边界情况

1. **栈为空时的操作**：
   - 当栈为空时，执行 `pop`、`top`、`getMin` 操作应该如何处理？通常，这种情况下，`pop` 和 `top` 操作可能需要抛出异常或返回一个特定值表示栈为空。对于 `getMin` 操作，同样需要有错误处理机制。

2. **单元素栈**：
   - 当栈中只有一个元素时，`getMin` 应该直接返回该元素，而 `pop` 操作后栈变为空，对 `getMin` 的处理需要重新考虑。

3. **重复元素**：
   - 如果栈中存在值相同的元素，确保 `getMin` 操作仍然可以正确返回最小值，即使最小值的元素被 `pop`。

### 约束

1. **常数时间内的最小值检索**：
   - 设计数据结构以确保 `getMin` 操作可以在常数时间内完成，这意味着不能遍历整个栈来查找最小元素。

2. **空间复杂度的考虑**：
   - 虽然可以使用额外的数据结构来存储每个元素对应的当前最小值，但是需要平衡空间复杂度和操作效率。

3. **操作的实现**：
   - `push`、`pop`、`top` 操作必须遵循栈的基本原则，即后进先出（LIFO）。

## 3. 算法和策略
### 算法设计

1. **辅助栈法**：
   - 使用两个栈，一个作为主栈存储所有元素（`stack`），另一个作为辅助栈（`minStack`）存储每次元素入栈后的当前最小值。
   - 当新元素 `x` 入栈时，将其推入主栈，同时比较 `x` 与辅助栈顶元素，将当前最小值推入辅助栈。
   - 进行 `pop` 操作时，主栈和辅助栈都要弹出栈顶元素。
   - `getMin` 直接返回辅助栈的栈顶元素，因为辅助栈顶始终是当前栈中的最小值。
   - `top` 操作只需返回主栈的栈顶元素。

### 策略说明

- **辅助栈的作用**：通过同步更新辅助栈，我们可以在任何时候快速获取到当前的最小值，而不需要额外的时间遍历计算。
- **处理边界情况**：对于栈为空的情况，可以在辅助栈初始化时先推入一个极大值，确保在只有一个元素时操作也能正常进行。对于 `pop` 和 `top` 操作，只要栈不为空，就可以直接进行。
- **优化空间复杂度**：虽然使用了额外的辅助栈，但是这是实现常数时间内获取最小值的必要代价。通过只存储当前最小值，而不是所有元素的排序或其他结构，可以相对减少空间复杂度。

---
