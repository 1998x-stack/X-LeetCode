[137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii)

[ChatGPT](https://chat.openai.com/share/cc94fba2-6601-4bde-be29-d48e8148004d)

---

## 1. 问题的内容
**1.1 题目描述**：
在LeetCode上，问题[137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii)的描述是这样的：给定一个整数数组 `nums`，除了某个元素仅出现一次外，其余每个元素均出现三次。找出那个只出现了一次的元素。

**说明**：

- 你的算法应当具有线性时间复杂度。即，时间复杂度应为O(n)。
- 你可以不使用额外空间来实现吗？（尽管这不是强制要求，但是如果能做到的话，会更好。）

**1.2 示例**：
- **输入**: `nums = [2,2,3,2]`
- **输出**: `3`
  
- **输入**: `nums = [0,1,0,1,0,1,99]`
- **输出**: `99`

**1.3 提示**:
- 根据问题要求，我们需要寻找一种有效的方法来识别出只出现一次的数字，同时保证算法的时间和空间效率。

## 2. 边界情况和约束
#### 边界情况

1. **数组长度**：最小为1，即数组中只有一个元素，这个元素就是答案。
2. **元素大小**：整数数组，没有明确给出数值范围，但应考虑到整数的正负和大小。
3. **重复次数**：除了一个元素外，其他元素恰好重复三次。

#### 约束

1. **时间复杂度**：要求算法具有线性时间复杂度O(n)，即我们需要在遍历数组一次内找到答案。
2. **空间复杂度**：最理想的情况是常数空间复杂度O(1)，即不使用额外的存储空间。


## 3. 算法和策略
1. **位运算法**：考虑到每个元素都出现三次，我们可以计算所有数字的每一位的和，然后对3取余。结果就是只出现一次的那个数字的对应位。
    - **步骤**：
        1. 初始化一个长度为32的数组`bitCounts`用于存储所有数字的每一位的和。
        2. 遍历输入数组`nums`，对于每个数字，更新`bitCounts`数组。
        3. 初始化结果`result`为0，然后遍历`bitCounts`数组，将每个元素对3取余，然后将这个余数加到`result`上。
        4. 返回`result`。

2. **数学方法**：利用数学公式，计算所有元素的三倍的和减去数组元素总和，差值再除以2就是只出现一次的数字。（这个方法在有的情况下可能不适用，因为题目要求不使用额外空间，且可能存在整数溢出问题）

---