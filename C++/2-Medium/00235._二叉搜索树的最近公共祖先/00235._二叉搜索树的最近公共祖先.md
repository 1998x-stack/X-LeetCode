[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree)

[ChatGPT](https://chat.openai.com/share/28d19d32-00a1-40ff-94e2-7d8158d1c8e0)

---

## 1. 问题的内容
**1.1 题目描述**：
在这个问题中，我们需要找到在一个二叉搜索树(BST)中两个指定节点的最近公共祖先(LCA)。所谓最近公共祖先，是指在树中最低的节点，同时是这两个节点的祖先。请注意，一个节点也可以是它自己的祖先。

二叉搜索树的特点是：
- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左右子树自身也都是二叉搜索树。

**1.2 示例**：
假设我们有以下的二叉搜索树：

```
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5
```

- 如果我们需要找的节点是2和8，那么最近公共祖先是6。
- 如果我们需要找的节点是2和4，那么最近公共祖先是2。

**1.3 提示**:
- 所有节点的值都是唯一的。
- p和q两个节点都存在于给定的二叉搜索树中。

## 2. 边界情况和约束
1. **树的大小**：
   - 空树：树中没有任何节点。
   - 只有一个节点：树中只有根节点。
   - 多个节点：正常情况，树中有多个节点。

2. **节点位置**：
   - p和q分别位于根节点的左右子树中：这是最理想的情况，根节点即为最近公共祖先。
   - p和q都位于根节点的同一侧子树中：需要在该侧子树中继续搜索最近公共祖先。
   - p或q中的一个是另一个的直接父节点：较高层级的节点即为最近公共祖先。

3. **特殊值处理**：
   - 所有节点的值都是唯一的，这简化了比较过程，因为不需要考虑有相同值的不同节点。
   - p和q保证存在于树中，这意味着不需要对不存在的节点进行处理。

4. **计算复杂度**：
   - 时间复杂度：最佳情况下为O(logN)，最坏情况下为O(N)，其中N为树中的节点数量。最佳情况发生在二叉搜索树是平衡的情况下，最坏情况发生在树退化成链表的情况下。
   - 空间复杂度：考虑到算法的递归性质，空间复杂度主要取决于递归调用栈的深度，最坏情况下为O(N)。

## 3. 算法和策略
### 算法设计

1. **从根节点开始**：
   - 检查当前节点是否为空，如果为空，则直接返回`NULL`。

2. **比较当前节点与p和q的值**：
   - 如果当前节点的值大于p和q的值，说明p和q都位于当前节点的左子树中，因此向左子树递归。
   - 如果当前节点的值小于p和q的值，说明p和q都位于当前节点的右子树中，因此向右子树递归。
   - 如果当前节点的值在p和q的值之间，或者等于p或q的值之一，那么当前节点就是p和q的最近公共祖先。

3. **递归终止条件**：
   - 找到最近公共祖先节点，或者遍历到叶子节点还没有找到，则返回找到的节点。

### 策略说明

- **利用二叉搜索树性质**：通过比较节点值，我们可以减少搜索范围，避免不必要的遍历。
- **递归搜索**：递归方法简洁明了，能够有效地在二叉搜索树中定位到最近公共祖先。
- **无需额外存储**：算法直接在给定的树结构上操作，不需要额外的存储空间来存储路径或节点。

---