[31. 下一个排列](https://leetcode.cn/problems/next-permutation)

[ChatGPT](https://chat.openai.com/share/b36a3ffc-1198-47b7-b5c1-d3ebc2405093)

---

## 1. 问题的内容
**1.1 题目描述**：
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成数字顺序下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

**1.2 示例**：
1. 输入: `[1,2,3]`
   输出: `[1,3,2]`
2. 输入: `[3,2,1]`
   输出: `[1,2,3]`
3. 输入: `[1,1,5]`
   输出: `[1,5,1]`

**1.3 提示**:
- 通过从右向左查找第一个不满足递增关系的数字，确定需要交换的边界。
- 从找到的边界位开始，向右查找刚好比边界位大的数字进行交换。
- 将边界位右侧的序列反转，确保这部分序列是升序的，这样可以保证得到的是下一个排列。

## 2. 边界情况和约束
**边界情况**:
- 输入序列完全逆序，如 `[3,2,1]`，此时需要重新排列成最小的排列。
- 输入序列中含有重复数字，如 `[1,5,1]`。

**约束**:
- 需要原地修改数组。
- 只允许使用额外常数空间。


## 3. 算法和策略
1. **从右向左查找第一个不满足递增关系的数字**:
   - 遍历数组，找到第一个位置`i`，使得`nums[i] < nums[i+1]`。这个位置是需要进行处理的起点。

2. **如果找到了这样的位置**:
   - 从数组末尾向左遍历，找到第一个大于`nums[i]`的数字，位置记为`j`。
   - 交换`nums[i]`和`nums[j]`。
   - 从位置`i+1`到数组末尾进行反转，确保这部分是升序的，即得到下一个排列。

3. **如果没有找到**（即整个数组是逆序的）:
   - 直接将整个数组反转，得到最小的排列。

---