[298. 二叉树最长连续序列](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence)

[ChatGPT](https://chat.openai.com/share/f609d4b2-0013-45bf-a011-852cd4495fb0)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一棵二叉树，找出其中最长的连续序列路径的长度。这个路径可以是从任何节点开始和结束的，但是它必须是向下的（我们只能从父节点移动到子节点），并且连续（我们要求节点的值在序列中是连续的）。

**1.2 示例**：
假设有一棵二叉树如下：

```
   1
    \
     3
    / \
   2   4
        \
         5
```

最长的连续序列路径是 `3-4-5`，因此输出应为 3。

再比如：

```
   2
    \
     3
    / 
   2    
  / 
 1   
```

最长的连续序列路径是 `2-3`，而不是 `3-2-1`，因为我们要求路径是向下的。因此输出应为 2。

**1.3 提示**:
- 二叉树的节点值是整数。
- 解决问题时，考虑使用深度优先搜索（DFS）策略，遍历整棵树，同时保持跟踪当前连续序列的长度以及最长连续序列的长度。

## 2. 边界情况和约束
### 边界情况

1. **空树**：如果二叉树为空，最长连续序列的长度为0。
2. **只有一个节点的树**：如果二叉树只有一个节点，最长连续序列的长度为1。
3. **所有节点值相同**：如果二叉树中所有节点的值相同，最长连续序列的长度取决于树的结构，但至少为1。
4. **非连续值**：如果二叉树中没有连续的序列，最长连续序列的长度为1，因为每个单独的节点可以被看作是长度为1的连续序列。

### 约束

- 二叉树节点的数量不会超过10000。
- 节点的值为整数。

## 3. 算法和策略
为了解决这个问题，我们可以采用深度优先搜索（DFS）的策略，递归遍历二叉树的每个节点，同时跟踪当前的连续序列长度以及遍历过程中遇到的最长连续序列的长度。下面是设计算法的详细步骤：

1. **初始化全局变量**：初始化一个全局变量`max_length`用于存储遍历过程中发现的最长连续序列的长度，初始值设为0。
2. **深度优先搜索（DFS）**：实现一个递归函数`dfs(node, parent_val, length)`，其中`node`是当前遍历到的节点，`parent_val`是父节点的值，`length`是到达当前节点时的连续序列长度。
   - 如果当前节点为空，直接返回。
   - 如果当前节点的值等于`parent_val + 1`，则当前连续序列长度`length`加1；否则，将连续序列长度重置为1，因为当前节点与父节点的值不连续。
   - 更新全局变量`max_length`，使其等于`max_length`和当前`length`的较大值。
   - 递归调用`dfs`函数，分别对当前节点的左子节点和右子节点进行遍历，传入当前节点的值作为`parent_val`，以及更新后的`length`。
3. **开始遍历**：从二叉树的根节点开始调用DFS函数，传入根节点、根节点的值减1（以确保根节点本身可以被计为长度为1的连续序列的开始），和初始序列长度1。
4. **返回结果**：DFS遍历完成后，全局变量`max_length`将包含最长连续序列的长度。返回`max_length`作为结果。

这个策略通过深度优先搜索遍历树的每个节点，同时用一个全局变量跟踪遇到的最长连续序列的长度，从而找到最长的连续序列路径。

---
