[255. 验证二叉搜索树的前序遍历序列](https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree)

[ChatGPT](https://chat.openai.com/share/daf239ab-d0be-45ca-a3a4-ef4f0b3ad014)

---

## 1. 问题的内容
**1.1 题目描述**：
验证给定的序列是否是某个二叉搜索树的前序遍历结果。在二叉搜索树中，每个节点的左子树只包含小于当前节点的数，每个节点的右子树只包含大于当前节点的数。序列中不包含重复的值。

**1.2 示例**：
- 输入: [5,2,6,1,3]，输出: false
- 输入: [5,2,1,3,6]，输出: true

**1.3 提示**:
- 可以假设序列中的数都是唯一的。
- 尝试使用不需要构建树的方法来解决问题。

## 2. 边界情况和约束
**边界情况**:
- 空序列：应视为有效的前序遍历序列。
- 单个元素的序列：同样视为有效的前序遍历序列。
- 所有元素相同的序列：题目已说明序列中的数都是唯一的，因此不考虑此情况。

**约束**:
- 序列长度的限制：没有明确说明，但应该考虑到实际内存和时间复杂度的限制。

## 3. 算法和策略
**设计算法和策略 - 极为详细**:
1. 利用栈来模拟前序遍历的过程，利用一个变量`lower_bound`来记录当前节点值可以取的最小值，初始值设为最小整数。
2. 遍历序列，对于每个元素执行以下步骤：
   1. 如果当前元素小于`lower_bound`，则返回false，因为这意味着我们尝试将一个较小的值插入到它应该是较大值的位置。
   2. 否则，当栈不为空且当前元素大于栈顶元素时，不断从栈中弹出元素，并更新`lower_bound`为弹出元素的值。这模拟了向右子树移动的过程，因此更新了新的最小值。
   3. 将当前元素压入栈中。
3. 如果整个过程中没有违反二叉搜索树的性质，则序列是有效的前序遍历序列。

---
