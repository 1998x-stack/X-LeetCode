[47. 全排列 II](https://leetcode.cn/problems/permutations-ii)

[ChatGPT](https://chat.openai.com/share/a15bfa0f-f51b-4cc1-8660-f42bc34a5934)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode 问题 [47. 全排列 II](https://leetcode.cn/problems/permutations-ii) 要求我们给定一个可能包含重复数字的序列，返回所有不重复的全排列。

**1.2 示例**：
输入: `[1,1,2]`
输出:
```
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

**1.3 提示**:
- 首先，需要考虑如何处理重复数字，以避免生成重复的排列。
- 其次，要设计一个高效的算法来生成所有可能的排列。

## 2. 边界情况和约束
边界情况可能包括：
- 输入序列为空。
- 输入序列只有一个元素。
- 输入序列所有元素都相同。

约束条件：
- 输入序列可能包含重复数字。


## 3. 算法和策略
1. **排序**：首先对数组进行排序，这样可以使得相同的数字聚集在一起，便于后续处理重复元素。
2. **回溯法**：使用回溯法来生成所有可能的排列。回溯法是一种通过探索所有可能的候选解来找到所有解的算法。如果一个候选解最终不是一个有效的解，回溯算法会丢弃它，并回溯到之前的步骤，尝试另一种可能。
3. **处理重复数字**：在生成排列的过程中，需要有一个机制来避免生成重复的排列。当我们在递归函数中遇到相同的数字时，只有当前一个相同数字已经被使用过，我们才可以使用当前数字，以此来避免产生重复的排列。
4. **使用标记数组**：使用一个额外的数组来标记哪些数字已经被使用过，以避免在同一个排列中重复使用同一个数字。

---