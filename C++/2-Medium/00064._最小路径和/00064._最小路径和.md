[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum)

[ChatGPT](https://chat.openai.com/share/994735bf-70ec-4de2-bc03-dd3a4b881f0d)

---

## 1. 问题的内容
**1.1 题目描述**：
- LeetCode上的问题编号64，题目名为"最小路径和"，链接为：https://leetcode.cn/problems/minimum-path-sum。
- 给定一个包含非负整数的 m x n 网格 `grid`，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
- 每次只能向下或者向右移动一步。

**1.2 示例**：
- 示例 1:
  输入: grid = [[1,3,1],[1,5,1],[4,2,1]]
  输出: 7
  解释: 因为路径 1→3→1→1→1 的总和最小。

- 示例 2:
  输入: grid = [[1,2,3],[4,5,6]]
  输出: 12

**1.3 提示**:
- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 200
- 0 <= grid[i][j] <= 100

## 2. 边界情况和约束
**边界情况**:
- `grid` 的大小为 1x1，这是最简单的情况，直接返回该单元格的值。
- `grid` 的行数或列数为 1，这意味着只能一直向右或一直向下移动，因此路径和为该行或列的所有元素之和。

**约束**:
- 网格中的数值为非负整数，范围为 [0, 100]。
- 网格的行数和列数的范围为 [1, 200]。

## 3. 算法和策略
**算法设计**:
1. 初始化一个同样大小的二维数组 `dp`，用于存储到达每个格子的最小路径和。
2. 设置 `dp[0][0]` 为 `grid[0][0]`，即起点的路径和为起点本身。
3. 遍历网格的第一行和第一列，由于这些位置只能由左边或上边的单元格达到，因此 `dp[i][0] = dp[i-1][0] + grid[i][0]`，`dp[0][j] = dp[0][j-1] + grid[0][j]`。
4. 对于网格中的其他位置 `(i, j)`，到达该位置的最小路径和可以通过从其左侧或上侧的单元格中选择一个路径和较小的来达到，即 `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`。
5. 最后，`dp[m-1][n-1]` 存储的就是到达网格右下角的最小路径和。

---