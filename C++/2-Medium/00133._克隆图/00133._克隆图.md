[133. 克隆图](https://leetcode.cn/problems/clone-graph)

[ChatGPT](https://chat.openai.com/share/7c51e6ef-5aa8-4ace-aeb2-df7ac4e77328)

---

## 1. 问题的内容
**1.1 题目描述**：
- 题目要求实现一个函数，克隆一个图。图中的每个节点都包含一个标签（`int`）和它的邻居列表（`vector<Neighbor>`）。
- 图是无向的。也就是说，如果节点 A 与节点 B 相邻，那么节点 B 也与节点 A 相邻。
- 函数的输入是图的一个节点的引用，应返回该图的深度复制（克隆）的引用。

**1.2 示例**：
假设图如下所示：

```
1 -- 2
|    |
4 -- 3
```

- 节点 1 的邻居是 2 和 4。
- 节点 2 的邻居是 1 和 3。
- 节点 3 的邻居是 2 和 4。
- 节点 4 的邻居是 1 和 3。

克隆这个图，返回克隆图的任何一个节点的引用。

**1.3 提示**:
- 可以使用深度优先搜索（DFS）或广度优先搜索（BFS）来克隆图。
- 需要用一个哈希表来存储原图节点与克隆图节点间的映射关系，以避免重复克隆节点和正确克隆邻居关系。
- 注意处理图中可能存在的环和自环情况。

## 2. 边界情况和约束
**边界情况**:
- **空图**: 输入的节点为 `nullptr`，应返回 `nullptr`。
- **单节点图**: 图中只有一个节点，没有边。
- **环形图**: 图中存在环，例如节点 1 指向节点 2，节点 2 指向节点 1。
- **自环图**: 节点自己指向自己，形成环。

**约束**:
- 图中的每个节点的标签都是唯一的。
- 图可以是任意大小，包括非常大的图。
- 图中可能存在自环和多重边。


## 3. 算法和策略
1. **使用哈希表存储已访问的节点**:
   - 键是原图中的节点，值是克隆图中的对应节点。
   - 这有助于快速查找节点是否已被克隆，同时防止无限循环（环的情况）。

2. **深度优先搜索（DFS）**:
   - 从给定的节点开始遍历图。
   - 对于每个遍历到的节点，如果它尚未被克隆，则创建一个新节点，并将其添加到哈希表中。
   - 递归地克隆每个邻居节点，并更新当前克隆节点的邻居列表。

3. **广度优先搜索（BFS）**（可选方案）:
   - 使用队列来实现层序遍历。
   - 类似于 DFS，但是使用队列来保持访问顺序，依次克隆每个节点及其邻居。

**详细策略**（选择DFS实现）:
- 初始化一个哈希表 `map<原始节点*, 克隆节点*>`。
- 对给定的节点执行 DFS:
  - 如果节点为空，返回空。
  - 如果节点已在哈希表中，返回哈希表中的克隆节点。
  - 创建一个新的克隆节点，并将原始节点和克隆节点加入哈希表。
  - 遍历原始节点的邻居列表，递归克隆每个邻居，并将克隆的邻居添加到克隆节点的邻居列表中。
- 返回克隆的图（即哈希表中给定节点的克隆节点）。

---