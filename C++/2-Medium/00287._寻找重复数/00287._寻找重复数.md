[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number)

[ChatGPT](https://chat.openai.com/share/edd0ec17-8b60-455c-8ec1-f4ae028972ff)

---

## 1. 问题的内容
**1.1 题目描述**：
- 给定一个包含 `n + 1` 个整数的数组 `nums`，其中每个整数都在 `1` 到 `n` 之间（包括 `1` 和 `n`），假设只有一个重复的整数，找出这个重复的数。
- 注意：不能更改原数组（假设数组是只读的），只能使用额外的 `O(1)` 的空间，并且时间复杂度应为 `O(n)`，数组中只有一个重复的数字，但它可能重复多次。

**1.2 示例**：
- 输入: `nums = [1,3,4,2,2]`
- 输出: `2`

**1.3 提示**:
- 如何在时间复杂度 `O(n)` 和空间复杂度 `O(1)` 的条件下解决这个问题？
- 考虑使用快慢指针的方法，这种方法通常用于检测链表中的环，可以将问题转化为链表环的检测问题。

## 2. 边界情况和约束
**边界情况**:
- 数组长度最小为 `2`（因为至少包含 `n + 1` 个元素，其中 `n >= 1`）。
- 所有数组元素都在 `1` 到 `n` 范围内。

**约束**:
- 数组是只读的，不能更改数组内容。
- 只能使用常数级别的额外空间。
- 数组中有且只有一个元素是重复的，但可能重复多次。


## 3. 算法和策略
1. 使用快慢指针法寻找重复数，将数组看作是链表，其中 `nums[i]` 的值表示链表中第 `i` 个节点指向的下一个节点的索引。
2. 初始化两个指针，快指针（`fast`）和慢指针（`slow`），初始时都指向数组的第一个元素。
3. 移动两个指针，慢指针每次移动一步（`slow = nums[slow]`），快指针每次移动两步（`fast = nums[nums[fast]]`）。
4. 继续移动快慢指针直到它们相遇，这个相遇点一定在环内。
5. 将快指针重新指向数组的第一个元素，然后再次以相同的速度（这次都是一步）移动快慢指针直到它们相遇。
6. 它们相遇的点就是重复的数，因为快慢指针以相同的速度移动，且从环的起点出发，它们最终会在环的入口相遇。

---
