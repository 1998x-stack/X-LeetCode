[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii)

[ChatGPT](https://chat.openai.com/share/7eec4c5a-9195-477c-8876-7fdf23826c17)

---

## 1. 问题的内容
**1.1 题目描述**：
问题来自 LeetCode，编号213，题目为"打家劫舍 II"。这个问题是关于一个盗贼打算从一个环形街区抢劫房屋。每个房子都有一定的金额，阻止盗贼抢劫相邻的房子的唯一制约是相邻的房子有安全系统连接，如果两个相邻的房子在同一晚上被抢劫，它会自动联系警察。

在这个版本的问题中，第一个房子和最后一个房子是相邻的。也就是说，房子形成一个圈。目标是确定盗贼可以抢劫的最大金额，而不会警告警察。

**1.2 示例**：
- 输入: `[2,3,2]`
- 输出: `3`
- 解释: 由于第一个房子和最后一个房子是相邻的，盗贼不能同时抢劫第一个房子和最后一个房子。所以，最大金额是抢劫第二个房子，金额为3。

- 输入: `[1,2,3,1]`
- 输出: `4`
- 解释: 盗贼可以抢劫第一个房子和第三个房子，得到的最大金额是1 + 3 = 4。

**1.3 提示**:
- 数字表示每个房子中的金额。
- 不能抢劫相邻的房子。
- 首尾房子视为相邻。

## 2. 边界情况和约束
#### 边界情况
- **空房子数组**：如果没有房子可以抢劫，那么最大金额显然是0。
- **只有一个房子**：如果只有一个房子，那么盗贼只能抢劫这一个房子。
- **只有两个房子**：如果只有两个房子，由于它们被认为是相邻的，盗贼只能选择其中金额较大的一个进行抢劫。

#### 约束
- 房子的数量为非负整数。
- 每个房子中的金额为非负整数。


## 3. 算法和策略
1. **基本思路**：由于房子是环形排列的，我们可以将问题分解为两个子问题来处理：一个是不包括第一个房子的情况，另一个是不包括最后一个房子的情况。然后，我们可以在这两个子问题中各自应用"打家劫舍 I"的解决方案，最后取这两个子问题解的最大值作为最终答案。
2. **"打家劫舍 I"的解决方案**：对于非环形的房子排列，我们可以使用动态规划的方法来解决。我们维护一个数组`dp`，其中`dp[i]`表示到达第`i`个房子时能抢到的最大金额，状态转移方程为`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`，其中`nums[i]`是第`i`个房子中的金额。
3. **处理环形排列的关键**：我们需要分两次计算，一次是考虑从第二个房子到最后一个房子的情况（即不抢第一个房子），另一次是考虑从第一个房子到倒数第二个房子的情况（即不抢最后一个房子）。每次计算都使用上述的动态规划方法。
4. **综合比较**：最后，我们比较这两次计算得到的最大金额，取最大值作为最终答案。

---
