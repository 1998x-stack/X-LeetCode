[309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown)

[ChatGPT](https://chat.openai.com/share/3884484e-7b1b-4aff-9a54-7d255f6a8994)

---

## 1. 问题的内容
**1.1 题目描述**：
- 给定一个整数数组`prices`，其中`prices[i]`表示第`i`天的股票价格。
- 你可以尽可能地完成更多的交易（买入和卖出一支股票），但是你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。另外，卖出股票后，你无法在第二天买入股票（即冷冻期为1天）。
- 计算你所能获取的最大利润。

**1.2 示例**：
- 输入: `prices = [1,2,3,0,2]`
- 输出: `3`
- 解释: 对应的交易状态为: `[买入, 卖出, 冷冻期, 买入, 卖出]`

**1.3 提示**:
- `1 <= prices.length <= 5000`
- `0 <= prices[i] <= 1000`

## 2. 边界情况和约束
对于问题[309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown)，我们需要分析的边界情况和约束包括：

1. **数组长度的边界**：根据题目提示，数组`prices`的长度范围是`1`到`5000`。这意味着我们的解决方案需要能够处理仅有一个元素的数组（即只有一天的股票价格），以及最多有`5000`个元素的数组。
   
2. **股票价格的范围**：股票价格`prices[i]`的范围是`0`到`1000`。我们的算法需要能够处理股票价格为`0`的情况（虽然实际上买卖股票时价格不可能为`0`，但这可以视为一种边界测试）。

3. **冷冻期的约束**：在卖出股票后的第二天，不能购买股票。这意味着我们的算法需要考虑到每次卖出操作后的冷冻期。

4. **买卖操作的约束**：不能同时参与多笔交易。这意味着在买入股票之前，必须已经卖出之前的股票。

5. **利润最大化**：目标是最大化利润，这意味着我们需要找到一种买卖策略，即使在考虑到冷冻期的约束下，也能够在给定的股票价格数组中获得最大利润。


## 3. 算法和策略
为了解决这个问题，我们可以使用动态规划的方法。我们定义三个状态，每天结束时每个状态的最大利润：

1. `hold`：当前持有一支股票的最大利润。
2. `notHold_cooldown`：当前不持有股票，并且处于冷冻期的最大利润。
3. `notHold`：当前不持有股票，并且不处于冷冻期的最大利润。

接下来，我们将这个问题分解成一系列子问题，并定义状态转移方程：

- 对于`hold`状态，我们有两个选择：要么我们继续持有昨天的股票，要么我们在今天买入股票（前提是昨天我们没有股票，并且也不处于冷冻期）。因此，
  \[ hold[i] = max(hold[i-1], notHold[i-1] - prices[i]) \]
  
- 对于`notHold_cooldown`状态，唯一的方式进入这个状态是在今天卖出我们持有的股票。
  \[ notHold_cooldown[i] = hold[i-1] + prices[i] \]
  
- 对于`notHold`状态，我们有两个选择：要么我们从昨天的`notHold`状态继续保持不买入，要么我们从冷冻期转出来。
  \[ notHold[i] = max(notHold[i-1], notHold_cooldown[i-1]) \]

**初始化**：

- 第0天`hold[0] = -prices[0]`，因为如果我们在第0天买入股票，那么利润就是`-prices[0]`。
- 第0天`notHold_cooldown[0] = 0`，因为在第0天我们不可能处于冷冻期。
- 第0天`notHold[0] = 0`，因为如果我们在第0天什么都不做，那么利润就是`0`。

**目标**：

- 我们的目标是在最后一天，找到`notHold`和`notHold_cooldown`中的最大值，因为最后一天我们不可能持有股票。

算法的步骤如下：

1. 初始化`hold`, `notHold_cooldown`, `notHold`数组。
2. 遍历`prices`数组，根据上述状态转移方程更新三个状态。
3. 返回`max(notHold[n-1], notHold_cooldown[n-1])`，其中`n`是`prices`数组的长度。

---
