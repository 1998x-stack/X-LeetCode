[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)

[ChatGPT](https://chat.openai.com/share/48714b93-1ec2-40df-8e48-3df05b2e0ce7)

---

## 1. 问题的内容
**1.1 题目描述**：
在一个二叉树中，找到两个节点的最近公共祖先（LCA）。最近公共祖先表示为对两个节点 `p` 和 `q`，在这棵树中最低的节点，同时包含 `p` 和 `q` 作为其后代（我们允许一个节点是其自身的后代）。二叉树不一定是二叉搜索树。

**1.2 示例**：
- **输入**: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
- **输出**: 3
- **解释**: 节点 5 和节点 1 的最近公共祖先是节点 3。

- **输入**: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
- **输出**: 5
- **解释**: 节点 5 和节点 4 的最近公共祖先是节点 5，因为根据定义，一个节点可以是其自身的最近公共祖先。

**1.3 提示**:
- 树中的节点数目在范围 [2, 10^5] 内。
- -10^9 <= Node.val <= 10^9
- 所有 Node.val 互不相同。
- p != q
- p 和 q 均存在于给定的二叉树中。

## 2. 边界情况和约束
**边界情况**:
- 如果 `p` 和 `q` 其中之一是另一个的父节点，则该节点即为最近公共祖先。
- 如果树只有两个节点，且这两个节点分别是 `p` 和 `q`，则根节点是它们的最近公共祖先。
- 如果 `p` 和 `q` 分布在根节点的两侧，根节点即为最近公共祖先。

**约束**:
- 需要考虑的是每个节点最多有两个子节点的情况，即这是一棵二叉树。
- 节点值唯一，可以用来区分每个节点。
- `p` 和 `q` 必定存在于树中，无需检查其存在性。


## 3. 算法和策略
1. **使用递归方法**:
   - 从根节点开始遍历树。
   - 如果当前节点为空或等于 `p` 或 `q`，则返回当前节点。
   - 递归地在左子树和右子树中查找 `p` 和 `q`。
   - 如果左子树查找结果不为空，且右子树查找结果也不为空，则说明 `p` 和 `q` 分别位于当前节点的两侧，当前节点即为它们的最近公共祖先。
   - 如果左子树和右子树查找结果有一个为空，另一个不为空，那么不为空的结果即为 `p` 和 `q` 的最近公共祖先。

2. **具体步骤**:
   - 定义一个递归函数 `findLCA(root, p, q)`，它接受当前节点以及两个节点 `p` 和 `q` 作为参数。
   - 如果 `root` 为空或 `root` 等于 `p` 或 `q`，返回 `root`。
   - 对 `root` 的左子节点调用 `findLCA`，对 `root` 的右子节点也调用 `findLCA`。
   - 如果左右两次调用的结果都非空，意味着找到了最近公共祖先，返回当前 `root`。
   - 如果只有一个结果非空，返回该非空结果。
   - 如果两个结果都为空，返回空。

---