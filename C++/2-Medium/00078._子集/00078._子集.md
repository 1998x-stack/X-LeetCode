[78. 子集](https://leetcode.cn/problems/subsets)

[ChatGPT](https://chat.openai.com/share/6b0cd0c8-ae73-4200-aac5-abc79d9742e2)

---

## 1. 问题的内容
**1.1 题目描述**：
题目[78. 子集](https://leetcode.cn/problems/subsets)要求我们给定一个整数数组 `nums`（无重复元素），返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。可以按任意顺序返回解集。


**1.2 示例**：
- **输入**: `nums = [1,2,3]`
- **输出**: `[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]`

- **输入**: `nums = [0]`
- **输出**: `[[],[0]]`

**1.3 提示**:
- 给定数组的长度满足 `1 <= nums.length <= 10`。
- 数组中的元素的取值范围是 `[-10, 10]`。
- 数组中的所有元素都是 **独一无二** 的。

## 2. 边界情况和约束
### 边界情况

- **最小数组**：数组长度为1时，子集为 `[[], [nums[0]]]`。
- **最大数组**：数组长度为10时，要考虑效率和避免重复。

### 约束

- **无重复元素**：由于数组中的元素独一无二，生成的子集中也不应包含重复元素。
- **空数组**：空数组是任何数组的子集，因此返回结果中应包含空数组。

## 3. 算法和策略
### 算法步骤

1. **初始化**：创建一个空列表 `result` 来存储所有的子集。
2. **递归函数定义**：定义一个递归函数 `backtrack(start, path)`，其中 `start` 是当前选择的起始位置，`path` 是当前构建的子集。
   - **递归结束条件**：当处理到数组的末尾时，将当前路径 `path` 添加到 `result` 中，然后返回。
3. **遍历**：从 `start` 开始遍历数组 `nums`，对于每个元素，有两种选择：选择或不选择。
   - **选择当前元素**：将当前元素添加到 `path` 中，然后递归调用 `backtrack(i + 1, path)`，之后撤销选择（回溯），以便进行下一次选择。
   - **不选择当前元素**：直接递归调用 `backtrack(i + 1, path)`，不修改 `path`。
4. **调用递归**：从索引 `0` 和空路径 `[]` 开始调用递归函数 `backtrack(0, [])`。
5. **返回结果**：返回存储所有子集的 `result` 列表。

### 策略细节

- **回溯的核心**：在遍历过程中，对每个元素都进行选择和不选择的尝试，通过递归探索所有可能的组合。
- **效率考虑**：通过递归的方式，我们可以避免重复构造子集，因为每次递归都是基于当前的选择状态。
- **空间优化**：通过在递归调用中直接修改和还原 `path`，我们可以避免使用额外的空间来存储临时路径，只需维护当前路径状态。

---