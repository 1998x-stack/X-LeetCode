[276. 栅栏涂色](https://leetcode.cn/problems/paint-fence)

[ChatGPT](https://chat.openai.com/share/8f30e4b1-1ae8-46d7-b8a4-d705e7c3a0f3)

---

## 1. 问题的内容
**1.1 题目描述**：
问题来自 LeetCode，编号 276，题目是“栅栏涂色”。我们需要计算涂色栅栏的方法数，使得最多只有两根相邻的栅栏颜色相同。

**参数**：
- 一个整数 `n`，表示栅栏的数量。
- 一个整数 `k`，表示可用的颜色数量。

**要求**：
计算所有可能的涂色方案的数量。

**1.2 示例**：
- 输入: `n = 3, k = 2`
- 输出: `6`

解释：我们有两种颜色可用。三根栅栏，可以有以下几种涂色方式（假设颜色为 A 和 B）：AAB, ABA, BAA, BBA, BAB, ABB。

**1.3 提示**:
- 不能有超过两根相邻的栅栏颜色相同。

## 2. 边界情况和约束
1. **边界情况**：
   - 当 `n` 或 `k` 为 0 时，无法进行涂色，因此返回 0。
   - 当 `n` 为 1 时，所有颜色都是可行的，因此返回 `k`。
   - 当 `n` 为 2 时，可以涂成相同颜色或不同颜色，因此方法数为 `k * k`。

2. **约束**：
   - `n` 和 `k` 都是正整数。
   - 不能有超过两根相邻的栅栏颜色相同，这意味着第三根栅栏开始的每一根栅栏都有限制。

## 3. 算法和策略
1. **初始化**：
   - 创建两个变量，`same` 和 `diff`，分别表示最后两根栅栏颜色相同和颜色不同的涂色方法数。初始时，`same = 0`（因为只有一根栅栏时，不存在相同颜色的情况），`diff = k`（因为第一根栅栏可以使用任何颜色）。

2. **遍历每一根栅栏**：
   - 从第二根栅栏开始遍历，直到第 `n` 根栅栏。
   - 对于每一根栅栏，我们可以基于前一根栅栏的涂色方法来更新 `same` 和 `diff`。

3. **更新规则**：
   - 新的 `same` 值应该是上一步的 `diff` 值，因为如果最后两根栅栏颜色相同，那么前一根栅栏的涂色方式必须与最后一根栅栏颜色不同。
   - 新的 `diff` 值是上一步的 `same + diff`（即总方法数）乘以 `k-1`，因为新加的栅栏可以选择除了最后一根栅栏颜色之外的任何颜色。

4. **重复**：
   - 重复步骤 2 和 3，直到遍历完所有栅栏。

5. **计算总方法数**：
   - 最终，将 `same + diff` 作为总方法数返回。

---