[384. 打乱数组](https://leetcode.cn/problems/shuffle-an-array)

[ChatGPT](https://chat.openai.com/share/08082d14-4e85-4fbb-8e29-6445f61c2fe6)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode问题384描述了一个称为"打乱数组"的问题。其主要目标是重新设计一个类，使其能够：

- 在初始化时接受一个整数数组。
- 提供一个函数来打乱该数组的顺序并返回。
- 提供一个函数来恢复数组至其原始顺序并返回。

**1.2 示例**：
如果输入的数组是 `[1,2,3]`，那么可能的打乱顺序为 `[1,3,2]`，`[2,1,3]`，`[2,3,1]`，`[3,1,2]`，`[3,2,1]`。注意，打乱后的数组应具有相同的每个元素的概率分布。

**1.3 提示**:
- 打乱函数应确保每个位置的元素都能等概率地出现在每个位置。
- 可以使用洗牌算法，如Fisher-Yates洗牌算法来实现。
- 初始化函数应存储数组的原始状态，以便可以恢复。
- 需要考虑如何高效地存储数组状态，以及如何实现打乱和恢复操作。

## 2. 边界情况和约束
### 边界情况：

1. **空数组**：输入数组可能为空，确保代码能够优雅处理这种情况。
2. **单元素数组**：数组只包含一个元素时，打乱操作实际上不会改变数组，但我们的代码应该能够处理这种情况。
3. **大数组**：考虑到性能，对于包含大量元素的数组，打乱算法应该尽可能高效。

### 约束：

1. **原地操作**：尽量在原数组上进行打乱操作，以节省空间复杂度，但原始数组的恢复需要保留一份原始数据的副本。
2. **等概率分布**：确保每个元素在每个位置上出现的概率相同。
3. **算法复杂度**：考虑到打乱和恢复操作的时间复杂度，应当寻求时间和空间上的平衡。
4. **随机性**：需要使用良好的随机数生成器来保证打乱的随机性。


## 3. 算法和策略
### 算法：Fisher-Yates 洗牌算法

**核心思想**：通过遍历数组，对于每个位置`i`，从`i`到数组末尾的任意位置随机选取一个元素，与位置`i`的元素交换。这样可以保证每个元素等概率出现在每个位置。

### 策略：

1. **初始化**：
   - 存储原始数组以供后续恢复使用。
   - 准备一个同样大小的数组用于打乱操作。

2. **打乱数组**：
   - 遍历数组，对于每个索引`i`，随机选择一个`[i, n-1]`范围内的索引`j`（`n`是数组的长度），然后交换索引`i`和索引`j`的元素。
   - 这一步骤需要确保随机选取索引的过程是公平的，以保证每个元素等概率出现在每个位置。

3. **恢复数组**：
   - 直接返回初始化时存储的原始数组副本。

### 算法细节和优化：

- **随机数生成**：使用`std::mt19937`（一种高质量的随机数生成器）和`std::uniform_int_distribution`来生成指定范围内的随机数，以确保随机性。
- **空间优化**：通过在初始化时仅存储原数组副本，并在打乱操作中直接在副本上操作，可以避免额外的空间消耗。
- **时间优化**：Fisher-Yates算法的时间复杂度为O(n)，这是打乱数组所能达到的最优时间复杂度，因为每个元素至少需要被访问一次。


---
