[313. 超级丑数](https://leetcode.cn/problems/super-ugly-number)

[ChatGPT](https://chat.openai.com/share/f5b54964-1f72-4062-81e8-0b051f5be484)

---

## 1. 问题的内容
**1.1 题目描述**：
**超级丑数** 是一个正整数，并满足其所有质因数都出现在给定的质因数列表中。给定一个数 `n` 和一个质因数列表 `primes`，找出第 `n` 个超级丑数。

**1.2 示例**：
假设 `n = 12`，`primes = [2, 7, 13, 19]`，第 `12` 个超级丑数是 `32`，因为其质因数只包含 `2`，而 `2` 在给定的质因数列表中。

**1.3 提示**:
- 超级丑数是一个相对于给定质因数列表的概念，与传统意义上的丑数（只包含质因数 `2`, `3`, `5` 的正整数）类似，但是其质因数范围更广。
- 输入的 `n` 是一个正整数，并且不会超过给定质因数列表能表示的最大的超级丑数。
- `primes` 数组中的每个元素都是质数，并且互不相同。

## 2. 边界情况和约束
### 边界情况

- 当 `n = 1` 时，根据超级丑数的定义，第一个超级丑数始终为 `1`，因为 `1` 没有质因数。
- 当 `primes` 数组只包含一个数，比如 `2`，时，超级丑数序列将与传统的丑数序列相同。
- 输入数组 `primes` 的大小和范围会对算法的时间复杂度和空间复杂度有重大影响。

### 约束

- `n` 和 `primes` 数组的大小应在合理范围内，以保证算法能在有限时间内计算出结果。
- `primes` 中的元素应保证是质数，且数组中的元素互不相同。


## 3. 算法和策略
### 算法步骤

1. **初始化**:
   - 创建一个大小为 `n` 的数组 `ugly`，用于存储前 `n` 个丑数，且 `ugly[0] = 1`（第一个丑数为1）。
   - 创建一个优先队列（最小堆），用于存储可能的丑数。
   - 对于给定的每个质因数 `prime`，将 `(prime * ugly[0], prime)` 的元组添加到优先队列中。这里，元组的第一个元素是可能的丑数，第二个元素是生成这个丑数的质因数。

2. **生成丑数**:
   - 重复以下步骤，直到找到 `n` 个丑数：
     - 从优先队列中弹出最小元素 `(num, prime)`。`num` 是当前最小的未使用丑数，`prime` 是生成这个丑数的质因数。
     - 如果 `num` 不等于 `ugly` 数组中最后一个元素（避免重复），则将 `num` 添加到 `ugly` 数组中。
     - 将新的元组 `(num * prime, prime)` 添加到优先队列中。这代表下一个可能由当前质因数 `prime` 生成的丑数。

3. **优化**:
   - 为减少重复计算和优化空间使用，我们可以在每次添加新丑数到优先队列时，检查是否已存在以避免重复。

4. **返回结果**:
   - 当 `ugly` 数组填满后，数组的最后一个元素即为第 `n` 个超级丑数。

### 策略详述

- **优先队列**（最小堆）的使用是为了保证每次能够从所有可能的丑数中选出最小的一个。
- **动态规划**的思想体现在使用 `ugly` 数组存储已找到的丑数，并基于这些丑数生成新的丑数，从而避免从头计算。
- **避免重复**的策略是关键，因为可能有多个质因数生成相同的丑数。通过比较即将添加的丑数与 `ugly` 数组最后一个元素，我们可以避免将相同的丑数添加到数组中。

---