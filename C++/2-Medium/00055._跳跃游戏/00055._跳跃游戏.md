[55. 跳跃游戏](https://leetcode.cn/problems/jump-game)

[ChatGPT](https://chat.openai.com/share/5133ab98-f5b0-4fa8-bc68-1e74d2fac010)

---

## 1. 问题的内容
**1.1 题目描述**：
- 问题链接为[55. 跳跃游戏](https://leetcode.cn/problems/jump-game)，其核心目标是判断给定一个非负整数数组 `nums`，你最初位于数组的第一个位置，数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

**1.2 示例**：
- 输入：`nums = [2,3,1,1,4]`
- 输出：`true`
- 解释：可以先跳 1 步，从位置 0 到达位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

**1.3 提示**:
- 1 <= `nums.length` <= 10^4
- 0 <= `nums[i]` <= 10^5

## 2. 边界情况和约束
**边界情况**：
- 数组长度为 1，此时起始位置即为终点，应直接返回 `true`。
- 数组中含有 0 的元素，需要特别注意，因为它可能阻止跳跃到达最后位置，除非它位于数组的末尾。

**约束**：
- 数组元素为非负整数，表示可以跳跃的最大长度。
- 跳跃次数不限，但每次跳跃长度受当前位置数组值的限制。


## 3. 算法和策略
**算法设计**：
1. 初始化一个变量 `maxReach` 来存储可以到达的最远距离，初始为 0。
2. 遍历数组，对于每个位置：
   - 首先检查这个位置是否可达（即索引小于等于 `maxReach`）。
   - 如果可达，更新 `maxReach` 为当前位置加上跳跃长度（`i + nums[i]`）和当前 `maxReach` 的较大值。
   - 如果在某个位置 `maxReach` 已经大于等于最后一个位置的索引，则返回 `true`。
3. 遍历结束后，如果 `maxReach` 小于最后一个位置的索引，则返回 `false`。

**策略**：
- 贪心算法：每一步都计算可以到达的最远距离，这样可以确保每一步都是局部最优解，从而达到全局最优。

---