[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence)

[ChatGPT](https://chat.openai.com/share/f7864837-0a2a-4e61-8ff5-514d9d71d03b)

---

## 1. 问题的内容
**1.1 题目描述**：
题目来源于 LeetCode，编号300，题目名为“最长递增子序列”。给定一个未排序的整数数组，找到最长递增子序列的长度。这里的子序列不需要连续，但必须是递增的。

**1.2 示例**：
- 输入: `[10,9,2,5,3,7,101,18]`
- 输出: `4`
- 解释: 最长的递增子序列是 `[2,3,7,101]`，因此长度是 `4`。

**1.3 提示**:
- 可以假设数组的长度不超过 3000 个，并且每个元素的大小范围是 `[−10^4, 10^4]`。

## 2. 边界情况和约束
#### 边界情况：
1. **空数组**：输入数组为空时，最长递增子序列的长度为0。
2. **单元素数组**：数组仅含一个元素时，最长递增子序列的长度为1。
3. **全递增或全递减数组**：当数组元素全递增时，整个数组本身就是最长递增子序列；当数组元素全递减时，最长递增子序列的长度为1（任意单个元素）。

#### 约束：
1. **元素范围**：数组中的每个元素的值范围为`[−10^4, 10^4]`。
2. **数组长度**：数组的长度不超过3000个元素。
3. **非连续性**：最长递增子序列中的元素在原数组中不需要连续。

## 3. 算法和策略
#### 算法步骤：
1. **初始化**：创建一个数组 `dp`，长度与输入数组相同，`dp[i]` 表示以第 `i` 个数字结尾的最长递增子序列的长度。初始时，每个元素的 `dp` 值至少为1，因为每个元素自身至少可以构成长度为1的递增子序列。

2. **遍历计算**：
   - 外层循环遍历数组中的每个元素，假设当前遍历到的元素为 `nums[i]`。
   - 内层循环遍历 `i` 之前的所有元素 `nums[j]`（`j` 从 `0` 遍历到 `i-1`），比较 `nums[j]` 和 `nums[i]` 的值：
     - 如果 `nums[j] < nums[i]`，说明 `nums[i]` 可以接在 `nums[j]` 构成的递增子序列之后形成一个新的递增子序列，此时我们更新 `dp[i]` 为 `dp[j] + 1` 和 `dp[i]` 当前值的较大值，即 `dp[i] = max(dp[i], dp[j] + 1)`。

3. **查找最大值**：遍历完成后，数组 `dp` 中的最大值即为整个数组的最长递增子序列的长度。

#### 算法复杂度：
- 时间复杂度：`O(n^2)`，其中 `n` 是数组的长度。需要两层循环遍历。
- 空间复杂度：`O(n)`，需要一个长度为 `n` 的 `dp` 数组。

#### 关键点：
- **状态定义**：`dp[i]` 表示以第 `i` 个数字结尾的最长递增子序列的长度。
- **状态转移方程**：`dp[i] = max(dp[i], dp[j] + 1)` 对于所有 `0 ≤ j < i` 且 `nums[j] < nums[i]`。

---
