[386. 字典序排数](https://leetcode.cn/problems/lexicographical-numbers)

[ChatGPT](https://chat.openai.com/share/3059a809-ec8f-42f7-adc8-2145e1533c4a)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode题目[386. 字典序排数](https://leetcode.cn/problems/lexicographical-numbers)要求我们给定一个整数 `n`，返回从 `1` 到 `n` 的数字按字典序排列的结果。

**1.2 示例**：
- 输入: `n = 13`
- 输出: `[1,10,11,12,13,2,3,4,5,6,7,8,9]`
这个例子说明了字典序排列并非按照数值大小排列，而是按照每个数字作为字符串时的字典序来排列的。


**1.3 提示**:
- 你可以假设 `n` 是一个正整数。

## 2. 边界情况和约束
在这个问题中，边界情况和约束主要包括：
- **边界情况**：最小的 `n` 值是 `1`。这种情况下，输出就是 `[1]`。
- **边界情况**：考虑到数字可能非常大，需要确认算法的时间复杂度和空间复杂度是否合理。
- **约束**：`n` 是一个正整数。



## 3. 算法和策略
为了解决这个问题，我们可以采用**深度优先搜索（DFS）**策略。算法的主要思路是从 `1` 到 `9` 开始遍历，对于每一个数字，尝试添加 `0` 到 `9` 到其后，形成新的数字，并继续进行深度优先搜索，直到数字超过 `n` 停止。

**算法详细步骤**：
1. 创建一个结果列表 `result` 用于存储字典序数字。
2. 使用一个辅助函数 `dfs` 来进行深度优先搜索。`dfs` 接受当前的数字 `cur` 和上限 `n`。
   - 如果 `cur` 大于 `n`，直接返回。
   - 否则，将 `cur` 添加到 `result` 中。
   - 从 `0` 到 `9` 遍历，对于每一个数字 `i`，计算新的数字 `newCur = cur * 10 + i`，并且如果 `newCur` 为 `0` 则跳过（因为不允许数字以 `0` 开头），然后递归调用 `dfs(newCur, n)`。
3. 从 `1` 到 `9` 调用 `dfs` 函数开始搜索。
4. 返回 `result` 列表。

---
