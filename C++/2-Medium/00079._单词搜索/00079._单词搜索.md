[79. 单词搜索](https://leetcode.cn/problems/word-search)

[ChatGPT](https://chat.openai.com/share/b57906f0-2dff-4697-94f8-91f66bca3419)

---

## 1. 问题的内容
**1.1 题目描述**：
给定一个 `m x n` 的二维字符网格 `board` 和一个字符串单词 `word`。如果 `word` 存在于网格中，返回 `true`；否则，返回 `false`。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**1.2 示例**：
- **输入**：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
- **输出**：true

- **输入**：board = [["a","b"],["c","d"]], word = "abcd"
- **输出**：false

**1.3 提示**:
- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成。

## 2. 边界情况和约束
- **边界情况**：
  - 网格大小为 `1x1`，单词长度为 1，且单词与网格中的字母相匹配。
  - 网格大小为最大值 `6x6`，单词长度为 15。
  - 单词在网格的边界开始和结束。
  - 单词路径在网格中需要转弯。

- **约束**：
  - 网格中的每个字母只能使用一次。
  - 单词必须是连续的，且只能在水平或垂直方向上搜索。

## 3. 算法和策略
**算法策略**：
使用**深度优先搜索（DFS）** + **回溯** 的方法来解决这个问题。算法的基本思路是，从网格中的每一个单元格出发，尝试所有可能的路径，看是否能够形成目标单词。

1. 从网格的每一个单元格开始搜索，匹配单词的第一个字母。
2. 如果第一个字母匹配，则从该单元格出发，向四个方向（上、下、左、右）搜索下一个字母。
3. 对于每一个方向，检查是否越界，以及该单元格是否已经被访问过，若未越界且未访问，则继续深度优先搜索。
4. 如果在任意步骤中，单词的所有字母都成功匹配，则返回 `true`。
5. 如果当前路径不匹配，回溯到上一步，尝试其他方向的搜索。
6. 如果所有单元格都无法形成目标单词，则返回 `false`。

---