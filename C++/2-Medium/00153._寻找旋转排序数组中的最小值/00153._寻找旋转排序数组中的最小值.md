[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array)

[ChatGPT](https://chat.openai.com/share/5add6f8d-705c-4c1a-bc8e-78aedc204679)

---

## 1. 问题的内容
**1.1 题目描述**：
在一个旋转排序的数组中寻找最小的元素。数组中没有重复的元素。

**1.2 示例**：

- 示例 1: 输入: `[3,4,5,1,2]`，输出: `1`
- 示例 2: 输入: `[4,5,6,7,0,1,2]`，输出: `0`

**1.3 提示**:
- 数组是由一个递增排序的数组在某个点上进行旋转。
- 数组的旋转意味着数组被分为两个递增的子序列，并且第二个子序列的所有元素都比第一个子序列的任何元素小。
- 你可以假设数组中不存在重复的元素。
- 你的算法的时间复杂度应该为 `O(log n)` 级别。

## 2. 边界情况和约束
**边界情况**:
- 数组长度为 `1`，此时数组本身就是最小值。
- 数组未旋转，即数组本身就是递增排序的，此时第一个元素就是最小值。

**约束**:
- 数组中的元素是唯一的，没有重复的元素。
- 要求算法的时间复杂度为 `O(log n)`，这提示我们应该使用二分查找或者相关的变种算法来解决问题。


## 3. 算法和策略
**算法设计**:
1. **初始化**：设置两个指针，`left` 和 `right`，分别指向数组的起始位置和结束位置。
2. **二分查找**：
   - 计算中间位置 `mid = (left + right) / 2`。
   - 检查 `mid` 与 `right` 指针的元素，以确定最小值是在左半部分还是右半部分：
     - 如果 `arr[mid] > arr[right]`，则最小值在 `mid+1` 到 `right` 之间，更新 `left = mid + 1`。
     - 否则，最小值在 `left` 到 `mid` 之间，更新 `right = mid`。
3. **终止条件**：当 `left` 等于 `right` 时，循环结束，此时 `left` 或 `right` 指向的就是最小值。

---