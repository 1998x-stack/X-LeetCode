[229. 多数元素 II](https://leetcode.cn/problems/majority-element-ii)

[ChatGPT](https://chat.openai.com/share/bb866ff3-7d15-4bde-9d33-f5d9a45378cf)

---

## 1. 问题的内容
**1.1 题目描述**：
在问题"多数元素 II"中，我们的目标是找出所有在大小为 n 的数组中出现超过 ⌊ n/3 ⌋ 次的元素。这意味着，我们要找出那些出现次数超过数组长度三分之一的元素。

**1.2 示例**：
- **示例 1**:
  - 输入: nums = [3,2,3]
  - 输出: [3]
  - 解释: 3 是数组中唯一一个出现超过 ⌊ 3/3 ⌋ = 1 次的元素。

- **示例 2**:
  - 输入: nums = [1,1,1,3,3,2,2,2]
  - 输出: [1,2]
  - 解释: 数组长度为 8，⌊ 8/3 ⌋ = 2，因此，1 和 2 都是有效的多数元素，因为它们都出现超过 2 次。

**1.3 提示**:
- 1 <= nums.length <= 5 * 10^4
- -10^9 <= nums[i] <= 10^9

## 2. 边界情况和约束
### 边界情况
1. **最小数组长度**：数组长度为1时，该元素自身就是多数元素II，因为它出现的次数超过了⌊1/3⌋=0次。
2. **所有元素都相同**：如果数组中所有元素相同，那么只要数组长度大于1，这个元素就不可能成为多数元素II，因为它出现的次数不可能超过⌊n/3⌋次。
3. **最大数组长度**：数组长度达到5 * 10^4时，需要确保算法在处理大数据量时仍然高效。

### 约束
1. **元素范围**：元素的值范围在-10^9到10^9之间，算法设计时需要考虑到这一点，避免整数溢出。
2. **时间复杂度**：考虑到数组长度的上限，我们的算法需要在合理的时间复杂度内完成计算，最好能够达到线性时间复杂度O(n)。
3. **空间复杂度**：由于题目没有特别限制空间复杂度，但出于效率考虑，应尽量设计使用较少额外空间的算法。

## 3. 算法和策略
1. **初始化**两个候选者(candidate1和candidate2)以及它们的计票(counter1和counter2)。
2. **遍历数组**：
   - 若当前元素与candidate1相同，counter1加1。
   - 若当前元素与candidate2相同，counter2加1。
   - 若counter1为0，将当前元素设为candidate1，并将counter1设为1。
   - 若counter2为0，将当前元素设为candidate2，并将counter2设为1。
   - 若当前元素既不是candidate1也不是candidate2，同时减少counter1和counter2。
3. **验证候选者**：由于上述步骤只是选出了可能超过 ⌊ n/3 ⌋ 的候选者，我们需要重新遍历数组来确认这些候选者的出现次数确实超过了 ⌊ n/3 ⌋。

---
