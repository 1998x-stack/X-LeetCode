[291. 单词规律 II](https://leetcode.cn/problems/word-pattern-ii)

[ChatGPT](https://chat.openai.com/share/4dc038b3-9529-4aa4-a246-2579fdac90b8)

---

## 1. 问题的内容
**1.1 题目描述**：
- 给定一个模式字符串`pattern`和一个字符串`s`，我们需要确定是否可以将`pattern`中的每个字母映射到`s`中的一个非空单词上，同时保持字符串`s`中的单词顺序。每个字母只能映射到一个单词上，每个单词也只能被一个字母映射。同时，映射必须是一对一的，不能有多对一或一对多的情况。

**1.2 示例**：
- 输入: pattern = "abab", s = "redblueredblue"
- 输出: true
- 解释: 映射方式为 a -> red, b -> blue。

**1.3 提示**:
1. `pattern`和`s`都只包含小写字母。
2. `s`的长度至少与`pattern`的长度相等，因为每个`pattern`中的字符至少需要映射到`s`中的一个字符。

## 2. 边界情况和约束
1. **空字符串**:
   - 如果`pattern`或`s`是空字符串，映射不可能成功。特别是，如果`pattern`为空而`s`不为空，或者`pattern`不为空而`s`为空，都应直接返回false。

2. **字符串长度**:
   - `s`的长度至少应等于`pattern`的长度。因为每个`pattern`中的字母至少需要映射到`s`中的一个字符。如果`s`的长度小于`pattern`的长度，映射不可能成功。

3. **一对一映射**:
   - 每个`pattern`中的字母必须映射到`s`中的唯一字符串，反之亦然。这意味着映射关系是双向唯一的，不能有多对一或一对多的情况。

4. **映射的连续性**:
   - `s`中映射到同一个`pattern`字母的子串，应该在每次出现该字母时都相同，并且这些子串在`s`中的出现顺序应与它们在`pattern`中的出现顺序相对应。


## 3. 算法和策略

#### 算法设计

1. **初始化**:
   - 创建一个映射表`map<char, string>`用于记录`pattern`中每个字符到`s`子串的映射。
   - 创建一个集合`set<string>`用于记录已经被映射的`s`子串，确保唯一性（一对一映射）。

2. **回溯函数设计**:
   - 定义一个回溯函数`bool backtrack(int patIndex, int sIndex, map<char, string>& map, set<string>& used)`，其中`patIndex`表示当前处理的`pattern`的位置，`sIndex`表示当前处理的`s`的位置。

3. **递归终止条件**:
   - 如果`patIndex`和`sIndex`都到达各自字符串的末尾，表示找到了一种映射方式，返回true。
   - 如果其中一个到达末尾而另一个没有，表示当前路径不匹配，返回false。

4. **遍历尝试映射**:
   - 从`sIndex`开始，遍历`s`中从当前位置开始的所有可能的子串，尝试将当前`pattern[patIndex]`映射到这个子串上。

5. **检查映射有效性**:
   - 如果当前字符已经有映射，则检查当前子串是否与之前的映射相同。如果不同，跳过当前子串。
   - 如果当前字符没有映射，但当前子串已被其他字符映射，同样跳过。

6. **尝试映射**:
   - 将当前字符和子串的映射加入映射表和已用集合，然后递归调用回溯函数，移动到下一个`pattern`字符和`s`中对应的新位置。

7. **撤销映射**:
   - 如果递归调用返回false，撤销当前步骤的映射（回溯），尝试`s`中的下一个子串。

8. **返回结果**:
   - 如果所有`pattern`字符都成功映射，函数最终返回true，否则返回false。

#### 策略说明

- 该算法使用回溯法探索所有可能的映射方式，通过递归尝试不同的字符到字符串的映射，并在遇到无法继续映射的情况时回溯。
- 通过维护一个映射表和一个已用集合，算法确保了映射的一对一性。
- 此方法在处理复杂映射问题时是有效的，尽管可能因为递归深度和尝试的子串数量而具有较高的时间复杂度。

---
