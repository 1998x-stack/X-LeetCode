[148. 排序链表](https://leetcode.cn/problems/sort-list)

[ChatGPT](https://chat.openai.com/g/g-GsMNEr76r-c-master)

---

## 1. 问题的内容
**1.1 题目描述**：
LeetCode题目148要求对一个链表进行排序。给定链表的头节点 `head`，需要返回排序后的链表的头节点。算法的空间复杂度应为常数级别，尽量达到 \(O(n \log n)\) 时间复杂度。

**1.2 示例**：
- **输入**: head = [4,2,1,3]
- **输出**: [1,2,3,4]

- **输入**: head = [-1,5,3,4,0]
- **输出**: [-1,0,3,4,5]

**1.3 提示**:
- 链表中节点的数目在范围 `[0, 5*10^4]` 内
- `-10^5 <= Node.val <= 10^5`

## 2. 边界情况和约束
#### 边界情况
1. **空链表**：当输入的链表为空时，应直接返回空。
2. **单节点链表**：链表只有一个节点时，不需要排序，直接返回该节点。
3. **全部节点值相同**：若链表中所有节点的值相同，则不需要调整节点顺序，直接返回原链表。

#### 约束
1. **空间复杂度**：必须为常数级别，即 \(O(1)\)。
2. **时间复杂度**：尽量达到 \(O(n \log n)\)，提示使用归并排序的链表版本实现。


## 3. 算法和策略
#### 算法设计
采用**归并排序**策略，归并排序适用于链表排序，因为它的合并操作能够自然而然地通过指针移动来完成，适合链表的结构，且可以满足常数空间复杂度的要求。

**步骤详解**:
1. **找到中点**：使用快慢指针法找到链表中点，快指针每次移动两步，慢指针每次移动一步，当快指针到达链表末尾时，慢指针即在中点。
2. **分割链表**：在中点将链表分割为两部分。
3. **递归排序**：递归地对两部分分别进行排序。
4. **合并排序链表**：将两个排序后的链表合并为一个排序链表。

#### 策略细化
- **寻找中点**：确保能够正确处理链表长度为偶数和奇数的情况。
- **分割链表**：更改中点的下一个节点的指针为 `nullptr`，以此来断开链表。
- **递归调用**：递归调用的终止条件是链表为空或链表仅有一个节点。
- **合并操作**：通过比较两个链表的头节点的值来进行合并，使用一个哨兵节点（dummy head）简化操作。

---