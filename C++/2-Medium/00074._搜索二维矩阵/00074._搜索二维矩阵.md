[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix)

[ChatGPT](https://chat.openai.com/share/0c440458-ed5a-45fa-9d6b-7a63da01300d)

---

## 1. 问题的内容
**1.1 题目描述**：
- LeetCode题目74，搜索一个二维矩阵。
- 矩阵中的每行从左到右升序排列。
- 每行的第一个元素大于前一行的最后一个元素。
- 需要编写一个高效的算法来判断矩阵中是否存在一个目标值。

**1.2 示例**：
```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

**1.3 提示**:
- 矩阵的行数和列数均不超过100。
- 你可以假设矩阵中的所有元素都是整数，目标值也是一个整数。

## 2. 边界情况和约束
在设计算法前，重要的一步是理解和分析问题的边界情况和约束条件。这有助于确保算法能够处理所有可能的输入场景，从而提高其鲁棒性和可靠性。

**边界情况**：
1. **矩阵为空**：这是最基本的边界情况，需要确保算法能够处理空矩阵的情况。
2. **矩阵只有一行或一列**：这种情况下矩阵退化为一维数组，算法需要能够正确处理。
3. **目标值小于矩阵中的最小值或大于最大值**：在这种情况下，可以直接返回`false`，无需遍历整个矩阵。
4. **目标值恰好是矩阵中的最小值或最大值**：算法需要能够正确判断这种边界情况。

**约束条件**：
1. **矩阵的行数和列数均不超过100**：这意味着算法的时间复杂度应该尽量控制在合理范围内，以处理最大规模的输入。
2. **矩阵中的元素以及目标值都是整数**：这个约束简化了比较操作，因为不需要考虑浮点数的精度问题。
3. **每行的第一个元素大于前一行的最后一个元素**：这个特性提示我们可以使用二分查找的方式来提高搜索效率。


## 3. 算法和策略
**算法步骤**：

1. **检查边界条件**：如果矩阵为空，直接返回`false`。

2. **行二分查找**：
   - 初始化行的左右指针`left = 0`，`right = matrix.size() - 1`。
   - 当`left <= right`时，计算中间行`mid = (left + right) / 2`。
   - 检查`mid`行的第一个元素和最后一个元素，以确定目标值是否可能位于该行：
     - 如果目标值小于该行的第一个元素，则`right = mid - 1`。
     - 如果目标值大于该行的最后一个元素，则`left = mid + 1`。
     - 否则，目标值可能在当前行，跳到步骤3。

3. **列二分查找**：
   - 在确定的行内，初始化列的左右指针`left = 0`，`right = matrix[0].size() - 1`。
   - 当`left <= right`时，计算中间列`mid = (left + right) / 2`。
   - 比较目标值与`mid`位置的元素：
     - 如果目标值小于`mid`位置的元素，则`right = mid - 1`。
     - 如果目标值大于`mid`位置的元素，则`left = mid + 1`。
     - 如果目标值等于`mid`位置的元素，则找到目标值，返回`true`。

4. **返回结果**：如果在任一步骤中找到目标值，则返回`true`；否则，在遍历完整个矩阵后返回`false`。

---