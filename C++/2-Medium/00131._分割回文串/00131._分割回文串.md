[131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning)

[ChatGPT](https://chat.openai.com/share/deba5c13-93f3-4ee5-80f1-cf5528aa9314)

---

## 1. 问题的内容
**1.1 题目描述**：
- 问题来自 LeetCode，编号 131，题目名为“分割回文串”。
- 目标是给定一个字符串 `s`，要将其分割成一些子串，使得每个子串都是回文串。返回所有可能的分割方案。

**1.2 示例**：
- 输入: `s = "aab"`
- 输出: `[["a","a","b"],["aa","b"]]`
- 解释: 有两种分割方式，一种是分割为 "a", "a", "b"；另一种是分割为 "aa", "b"。

**1.3 提示**:
- `s` 仅包含小写英文字母。
- 分割方式的顺序是按照在输入字符串中从左到右的顺序。

## 2. 边界情况和约束
**边界情况**:
- 当 `s` 为空字符串时，应返回一个包含空列表的列表，因为没有字符可以分割。
- 当 `s` 长度为 1 时，只有一种分割方式，即它自身，因为单个字符总是回文串。

**约束**:
- 字符串 `s` 的长度在实际应用中会受到内存和性能的限制。
- 分割的子串必须连续且覆盖原字符串 `s` 的所有字符，不能重排字符。


## 3. 算法和策略
**算法设计**:
1. 使用回溯法进行深度优先搜索（DFS），探索所有可能的分割方式。
2. 创建一个辅助函数 `isPalindrome`，用于检查一个字符串是否是回文。
3. 在 DFS 过程中，从字符串的左侧开始，逐渐增加切割点，对于每一个切割点，检查左侧的子串是否是回文。
   - 如果是回文，则将其添加到当前分割方案中，并继续从切割点的下一个位置开始探索。
   - 如果不是回文，则跳过当前切割点，尝试下一个切割点。
4. 当达到字符串的末尾时，将当前分割方案添加到结果集中。
5. 递归回溯，撤销上一步的选择，继续尝试其他分割点。

**策略细节**:
- **isPalindrome 函数**：从字符串两端开始向中间遍历，如果两端的字符不同，则不是回文。
- **回溯法**：
  - 维护一个当前分割方案的列表 `currentPartition` 和一个结果集 `result`。
  - 从字符串的第一个字符开始，尝试所有可能的切割点，使用 `substr` 方法获取子串。
  - 每次成功的切割（即得到一个回文子串）后，递归地继续处理剩余的字符串。
  - 当处理完整个字符串时，将 `currentPartition` 复制到 `result` 中。
  - 在每次递归返回前，需要撤销最后一次添加到 `currentPartition` 中的子串，以保证回溯正确进行。

---