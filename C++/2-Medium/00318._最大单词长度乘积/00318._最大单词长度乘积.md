[318. 最大单词长度乘积](https://leetcode.cn/problems/maximum-product-of-word-lengths)

[ChatGPT](https://chat.openai.com/share/a363c463-b951-4cbe-8f38-b428c8fefc34)

---

## 1. 问题的内容
**1.1 题目描述**：
**问题内容**: 给定一个字符串数组 `words`，找出 `words[i]` 和 `words[j]` 之间长度的乘积最大值，其中两个字符串不包含相同的字符。你可以假设每个字符串只包含小写字母。如果不存在这样的两个字符串，返回 0。

**1.2 示例**：
输入: `["abcw","baz","foo","bar","xtfn","abcdef"]`
输出: 16 
解释: 这组字符串中，`"abcw"` 和 `"xtfn"` 满足条件（没有相同字符），它们长度的乘积是 4 * 4 = 16。

**1.3 提示**:
- 字符串数组 `words` 的长度不会超过 1000。
- 字符串 `words[i]` 的长度不会超过 1000。

## 2. 边界情况和约束
**边界情况**:

1. `words` 数组为空，没有字符串，返回 0。
2. `words` 数组中只有一个字符串，没有其他字符串与之比较，返回 0。
3. `words` 数组中所有字符串都有至少一个共同字符，没有满足条件的字符串对，返回 0。

**约束**:

1. 所有字符串都只包含小写字母，总共有 26 个小写字母。
2. 字符串数组 `words` 的长度和字符串 `words[i]` 的长度的最大值分别为 1000。


## 3. 算法和策略
1. **初始化**：定义一个整数 `maxProduct` 保存最大乘积值，初始为 0。
2. **字符标记**：
   - 创建一个整型数组 `masks`，长度与 `words` 相同，用于存储每个字符串的字符标记。字符标记是一个整数，其二进制表示中的每一位代表一个字符是否出现过（26位足以代表所有小写字母）。
   - 遍历 `words` 数组，对于每个字符串，通过字符-'a'的结果来找到字符对应的位，并将其置为1（使用位操作 `|=` 和移位操作 `<<`）。
3. **计算乘积**：
   - 双层循环遍历 `masks` 数组，对于每一对字符串（使用索引 `i` 和 `j`），检查它们是否没有共同字符。这可以通过将两个字符串对应的 `masks` 值进行 `与` 操作 (`&`) 并检查结果是否为 0 来实现。
   - 如果没有共同字符，计算这两个字符串长度的乘积，并更新 `maxProduct` 为当前乘积和 `maxProduct` 中的较大值。
4. **返回结果**：最后返回 `maxProduct` 作为结果。

---